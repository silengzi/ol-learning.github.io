import{ba as M,L as A,K as P,G as F,b2 as _,bb as b,ap as x,s as L,b0 as v,b1 as f,bc as S,bd as Y,be as I,bf as X,bg as w,bh as O,bi as T,bj as j,bk as D,bl as K,aZ as y,bm as $,bn as k,aY as U,bo as Z,U as p,bp as q,bq as z}from"./Layer-3b715193.js";import{L as G}from"./LineString-eed53b5a.js";import{b as B,i as H,c as N}from"./featureloader-a90a5108.js";import{M as J}from"./MultiPoint-74fca651.js";class c extends M{constructor(t){super(),this.geometries_=t,this.changeEventsKeys_=[],this.listenGeometriesChange_()}unlistenGeometriesChange_(){this.changeEventsKeys_.forEach(A),this.changeEventsKeys_.length=0}listenGeometriesChange_(){const t=this.geometries_;for(let e=0,s=t.length;e<s;++e)this.changeEventsKeys_.push(P(t[e],F.CHANGE,this.changed,this))}clone(){const t=new c(C(this.geometries_));return t.applyProperties(this),t}closestPointXY(t,e,s,i){if(i<_(this.getExtent(),t,e))return i;const n=this.geometries_;for(let o=0,a=n.length;o<a;++o)i=n[o].closestPointXY(t,e,s,i);return i}containsXY(t,e){const s=this.geometries_;for(let i=0,n=s.length;i<n;++i)if(s[i].containsXY(t,e))return!0;return!1}computeExtent(t){b(t);const e=this.geometries_;for(let s=0,i=e.length;s<i;++s)x(t,e[s].getExtent());return t}getGeometries(){return C(this.geometries_)}getGeometriesArray(){return this.geometries_}getGeometriesArrayRecursive(){let t=[];const e=this.geometries_;for(let s=0,i=e.length;s<i;++s)e[s].getType()===this.getType()?t=t.concat(e[s].getGeometriesArrayRecursive()):t.push(e[s]);return t}getSimplifiedGeometry(t){if(this.simplifiedGeometryRevision!==this.getRevision()&&(this.simplifiedGeometryMaxMinSquaredTolerance=0,this.simplifiedGeometryRevision=this.getRevision()),t<0||this.simplifiedGeometryMaxMinSquaredTolerance!==0&&t<this.simplifiedGeometryMaxMinSquaredTolerance)return this;const e=[],s=this.geometries_;let i=!1;for(let n=0,o=s.length;n<o;++n){const a=s[n],r=a.getSimplifiedGeometry(t);e.push(r),r!==a&&(i=!0)}return i?new c(e):(this.simplifiedGeometryMaxMinSquaredTolerance=t,this)}getType(){return"GeometryCollection"}intersectsExtent(t){const e=this.geometries_;for(let s=0,i=e.length;s<i;++s)if(e[s].intersectsExtent(t))return!0;return!1}isEmpty(){return this.geometries_.length===0}rotate(t,e){const s=this.geometries_;for(let i=0,n=s.length;i<n;++i)s[i].rotate(t,e);this.changed()}scale(t,e,s){s||(s=L(this.getExtent()));const i=this.geometries_;for(let n=0,o=i.length;n<o;++n)i[n].scale(t,e,s);this.changed()}setGeometries(t){this.setGeometriesArray(C(t))}setGeometriesArray(t){this.unlistenGeometriesChange_(),this.geometries_=t,this.listenGeometriesChange_(),this.changed()}applyTransform(t){const e=this.geometries_;for(let s=0,i=e.length;s<i;++s)e[s].applyTransform(t);this.changed()}translate(t,e){const s=this.geometries_;for(let i=0,n=s.length;i<n;++i)s[i].translate(t,e);this.changed()}disposeInternal(){this.unlistenGeometriesChange_(),super.disposeInternal()}}function C(R){return R.map(t=>t.clone())}const et=c;class u extends v{constructor(t,e,s){if(super(),this.ends_=[],this.maxDelta_=-1,this.maxDeltaRevision_=-1,Array.isArray(t[0]))this.setCoordinates(t,e);else if(e!==void 0&&s)this.setFlatCoordinates(e,t),this.ends_=s;else{const i=t,n=[],o=[];for(let r=0,l=i.length;r<l;++r){const d=i[r];f(n,d.getFlatCoordinates()),o.push(n.length)}const a=i.length===0?this.getLayout():i[0].getLayout();this.setFlatCoordinates(a,n),this.ends_=o}}appendLineString(t){f(this.flatCoordinates,t.getFlatCoordinates().slice()),this.ends_.push(this.flatCoordinates.length),this.changed()}clone(){const t=new u(this.flatCoordinates.slice(),this.layout,this.ends_.slice());return t.applyProperties(this),t}closestPointXY(t,e,s,i){return i<_(this.getExtent(),t,e)?i:(this.maxDeltaRevision_!=this.getRevision()&&(this.maxDelta_=Math.sqrt(S(this.flatCoordinates,0,this.ends_,this.stride,0)),this.maxDeltaRevision_=this.getRevision()),Y(this.flatCoordinates,0,this.ends_,this.stride,this.maxDelta_,!1,t,e,s,i))}getCoordinateAtM(t,e,s){return this.layout!="XYM"&&this.layout!="XYZM"||this.flatCoordinates.length===0?null:(e=e!==void 0?e:!1,s=s!==void 0?s:!1,B(this.flatCoordinates,0,this.ends_,this.stride,t,e,s))}getCoordinates(){return I(this.flatCoordinates,0,this.ends_,this.stride)}getEnds(){return this.ends_}getLineString(t){return t<0||this.ends_.length<=t?null:new G(this.flatCoordinates.slice(t===0?0:this.ends_[t-1],this.ends_[t]),this.layout)}getLineStrings(){const t=this.flatCoordinates,e=this.ends_,s=this.layout,i=[];let n=0;for(let o=0,a=e.length;o<a;++o){const r=e[o],l=new G(t.slice(n,r),s);i.push(l),n=r}return i}getFlatMidpoints(){const t=[],e=this.flatCoordinates;let s=0;const i=this.ends_,n=this.stride;for(let o=0,a=i.length;o<a;++o){const r=i[o],l=H(e,s,r,n,.5);f(t,l),s=r}return t}getSimplifiedGeometryInternal(t){const e=[],s=[];return e.length=X(this.flatCoordinates,0,this.ends_,this.stride,t,e,0,s),new u(e,"XY",s)}getType(){return"MultiLineString"}intersectsExtent(t){return w(this.flatCoordinates,0,this.ends_,this.stride,t)}setCoordinates(t,e){this.setLayout(e,t,2),this.flatCoordinates||(this.flatCoordinates=[]);const s=O(this.flatCoordinates,0,t,this.stride,this.ends_);this.flatCoordinates.length=s.length===0?0:s[s.length-1],this.changed()}}const st=u;class m extends v{constructor(t,e,s){if(super(),this.endss_=[],this.flatInteriorPointsRevision_=-1,this.flatInteriorPoints_=null,this.maxDelta_=-1,this.maxDeltaRevision_=-1,this.orientedRevision_=-1,this.orientedFlatCoordinates_=null,!s&&!Array.isArray(t[0])){const i=t,n=[],o=[];for(let a=0,r=i.length;a<r;++a){const l=i[a],d=n.length,h=l.getEnds();for(let g=0,E=h.length;g<E;++g)h[g]+=d;f(n,l.getFlatCoordinates()),o.push(h)}e=i.length===0?this.getLayout():i[0].getLayout(),t=n,s=o}e!==void 0&&s?(this.setFlatCoordinates(e,t),this.endss_=s):this.setCoordinates(t,e)}appendPolygon(t){let e;if(!this.flatCoordinates)this.flatCoordinates=t.getFlatCoordinates().slice(),e=t.getEnds().slice(),this.endss_.push();else{const s=this.flatCoordinates.length;f(this.flatCoordinates,t.getFlatCoordinates()),e=t.getEnds().slice();for(let i=0,n=e.length;i<n;++i)e[i]+=s}this.endss_.push(e),this.changed()}clone(){const t=this.endss_.length,e=new Array(t);for(let i=0;i<t;++i)e[i]=this.endss_[i].slice();const s=new m(this.flatCoordinates.slice(),this.layout,e);return s.applyProperties(this),s}closestPointXY(t,e,s,i){return i<_(this.getExtent(),t,e)?i:(this.maxDeltaRevision_!=this.getRevision()&&(this.maxDelta_=Math.sqrt(T(this.flatCoordinates,0,this.endss_,this.stride,0)),this.maxDeltaRevision_=this.getRevision()),j(this.getOrientedFlatCoordinates(),0,this.endss_,this.stride,this.maxDelta_,!0,t,e,s,i))}containsXY(t,e){return D(this.getOrientedFlatCoordinates(),0,this.endss_,this.stride,t,e)}getArea(){return K(this.getOrientedFlatCoordinates(),0,this.endss_,this.stride)}getCoordinates(t){let e;return t!==void 0?(e=this.getOrientedFlatCoordinates().slice(),y(e,0,this.endss_,this.stride,t)):e=this.flatCoordinates,$(e,0,this.endss_,this.stride)}getEndss(){return this.endss_}getFlatInteriorPoints(){if(this.flatInteriorPointsRevision_!=this.getRevision()){const t=N(this.flatCoordinates,0,this.endss_,this.stride);this.flatInteriorPoints_=k(this.getOrientedFlatCoordinates(),0,this.endss_,this.stride,t),this.flatInteriorPointsRevision_=this.getRevision()}return this.flatInteriorPoints_}getInteriorPoints(){return new J(this.getFlatInteriorPoints().slice(),"XYM")}getOrientedFlatCoordinates(){if(this.orientedRevision_!=this.getRevision()){const t=this.flatCoordinates;U(t,0,this.endss_,this.stride)?this.orientedFlatCoordinates_=t:(this.orientedFlatCoordinates_=t.slice(),this.orientedFlatCoordinates_.length=y(this.orientedFlatCoordinates_,0,this.endss_,this.stride)),this.orientedRevision_=this.getRevision()}return this.orientedFlatCoordinates_}getSimplifiedGeometryInternal(t){const e=[],s=[];return e.length=Z(this.flatCoordinates,0,this.endss_,this.stride,Math.sqrt(t),e,0,s),new m(e,"XY",s)}getPolygon(t){if(t<0||this.endss_.length<=t)return null;let e;if(t===0)e=0;else{const n=this.endss_[t-1];e=n[n.length-1]}const s=this.endss_[t].slice(),i=s[s.length-1];if(e!==0)for(let n=0,o=s.length;n<o;++n)s[n]-=e;return new p(this.flatCoordinates.slice(e,i),this.layout,s)}getPolygons(){const t=this.layout,e=this.flatCoordinates,s=this.endss_,i=[];let n=0;for(let o=0,a=s.length;o<a;++o){const r=s[o].slice(),l=r[r.length-1];if(n!==0)for(let h=0,g=r.length;h<g;++h)r[h]-=n;const d=new p(e.slice(n,l),t,r);i.push(d),n=l}return i}getType(){return"MultiPolygon"}intersectsExtent(t){return q(this.getOrientedFlatCoordinates(),0,this.endss_,this.stride,t)}setCoordinates(t,e){this.setLayout(e,t,3),this.flatCoordinates||(this.flatCoordinates=[]);const s=z(this.flatCoordinates,0,t,this.stride,this.endss_);if(s.length===0)this.flatCoordinates.length=0;else{const i=s[s.length-1];this.flatCoordinates.length=i.length===0?0:i[i.length-1]}this.changed()}}const it=m;export{et as G,it as M,st as a};
