import{Z as We,bA as Ae,bB as Be,bf as kt,bk as ie,bt as se,bC as Pe,b2 as j,b5 as ue,b3 as fe,bD as st,bE as nt,b4 as ge,b6 as _e,b7 as pe,aG as xe,bF as ve,aS as Se,bG as Ye,b9 as V,j as Nt,bH as et,bI as Bt,bJ as Pt,bK as Ge,bL as Ne,a1 as ne,bM as Xe,aF as vt,bN as Ke,a2 as ye,Y as ft,at as oe,bO as He,aP as me,bP as Je,bQ as le,W as Ie,R as Yt,aj as je,a5 as Gt,i as Ve,B as he}from"./Layer-227d2e40.js";import{V as ze,C as Ze}from"./vector-841020ca.js";import{b as bt}from"./Style-f78957a3.js";import{a as Ue,I as qe}from"./featureloader-41324978.js";const _t={BEGIN_GEOMETRY:0,BEGIN_PATH:1,CIRCLE:2,CLOSE_PATH:3,CUSTOM:4,DRAW_CHARS:5,DRAW_IMAGE:6,END_GEOMETRY:7,FILL:8,MOVE_TO_LINE_TO:9,SET_FILL_STYLE:10,SET_STROKE_STYLE:11,STROKE:12},Ct=[_t.FILL],tt=[_t.STROKE],it=[_t.BEGIN_PATH],ae=[_t.CLOSE_PATH],m=_t;class $e extends ze{constructor(t,i,e,s){super(),this.tolerance=t,this.maxExtent=i,this.pixelRatio=s,this.maxLineWidth=0,this.resolution=e,this.beginGeometryInstruction1_=null,this.beginGeometryInstruction2_=null,this.bufferedMaxExtent_=null,this.instructions=[],this.coordinates=[],this.tmpCoordinate_=[],this.hitDetectionInstructions=[],this.state={}}applyPixelRatio(t){const i=this.pixelRatio;return i==1?t:t.map(function(e){return e*i})}appendFlatPointCoordinates(t,i){const e=this.getBufferedMaxExtent(),s=this.tmpCoordinate_,n=this.coordinates;let o=n.length;for(let l=0,h=t.length;l<h;l+=i)s[0]=t[l],s[1]=t[l+1],We(e,s)&&(n[o++]=s[0],n[o++]=s[1]);return o}appendFlatLineCoordinates(t,i,e,s,n,o){const l=this.coordinates;let h=l.length;const a=this.getBufferedMaxExtent();o&&(i+=s);let r=t[i],d=t[i+1];const c=this.tmpCoordinate_;let u=!0,f,x,_;for(f=i+s;f<e;f+=s)c[0]=t[f],c[1]=t[f+1],_=Ae(a,c),_!==x?(u&&(l[h++]=r,l[h++]=d,u=!1),l[h++]=c[0],l[h++]=c[1]):_===Be.INTERSECTING?(l[h++]=c[0],l[h++]=c[1],u=!1):u=!0,r=c[0],d=c[1],x=_;return(n&&u||f===i+s)&&(l[h++]=r,l[h++]=d),h}drawCustomCoordinates_(t,i,e,s,n){for(let o=0,l=e.length;o<l;++o){const h=e[o],a=this.appendFlatLineCoordinates(t,i,h,s,!1,!1);n.push(a),i=h}return i}drawCustom(t,i,e,s){this.beginGeometry(t,i);const n=t.getType(),o=t.getStride(),l=this.coordinates.length;let h,a,r,d,c;switch(n){case"MultiPolygon":h=t.getOrientedFlatCoordinates(),d=[];const u=t.getEndss();c=0;for(let f=0,x=u.length;f<x;++f){const _=[];c=this.drawCustomCoordinates_(h,c,u[f],o,_),d.push(_)}this.instructions.push([m.CUSTOM,l,d,t,e,se]),this.hitDetectionInstructions.push([m.CUSTOM,l,d,t,s||e,se]);break;case"Polygon":case"MultiLineString":r=[],h=n=="Polygon"?t.getOrientedFlatCoordinates():t.getFlatCoordinates(),c=this.drawCustomCoordinates_(h,0,t.getEnds(),o,r),this.instructions.push([m.CUSTOM,l,r,t,e,ie]),this.hitDetectionInstructions.push([m.CUSTOM,l,r,t,s||e,ie]);break;case"LineString":case"Circle":h=t.getFlatCoordinates(),a=this.appendFlatLineCoordinates(h,0,h.length,o,!1,!1),this.instructions.push([m.CUSTOM,l,a,t,e,kt]),this.hitDetectionInstructions.push([m.CUSTOM,l,a,t,s||e,kt]);break;case"MultiPoint":h=t.getFlatCoordinates(),a=this.appendFlatPointCoordinates(h,o),a>l&&(this.instructions.push([m.CUSTOM,l,a,t,e,kt]),this.hitDetectionInstructions.push([m.CUSTOM,l,a,t,s||e,kt]));break;case"Point":h=t.getFlatCoordinates(),this.coordinates.push(h[0],h[1]),a=this.coordinates.length,this.instructions.push([m.CUSTOM,l,a,t,e]),this.hitDetectionInstructions.push([m.CUSTOM,l,a,t,s||e]);break}this.endGeometry(i)}beginGeometry(t,i){this.beginGeometryInstruction1_=[m.BEGIN_GEOMETRY,i,0,t],this.instructions.push(this.beginGeometryInstruction1_),this.beginGeometryInstruction2_=[m.BEGIN_GEOMETRY,i,0,t],this.hitDetectionInstructions.push(this.beginGeometryInstruction2_)}finish(){return{instructions:this.instructions,hitDetectionInstructions:this.hitDetectionInstructions,coordinates:this.coordinates}}reverseHitDetectionInstructions(){const t=this.hitDetectionInstructions;t.reverse();let i;const e=t.length;let s,n,o=-1;for(i=0;i<e;++i)s=t[i],n=s[0],n==m.END_GEOMETRY?o=i:n==m.BEGIN_GEOMETRY&&(s[2]=i,Pe(this.hitDetectionInstructions,o,i),o=-1)}setFillStrokeStyle(t,i){const e=this.state;if(t){const s=t.getColor();e.fillStyle=bt(s||j)}else e.fillStyle=void 0;if(i){const s=i.getColor();e.strokeStyle=bt(s||ue);const n=i.getLineCap();e.lineCap=n!==void 0?n:fe;const o=i.getLineDash();e.lineDash=o?o.slice():st;const l=i.getLineDashOffset();e.lineDashOffset=l||nt;const h=i.getLineJoin();e.lineJoin=h!==void 0?h:ge;const a=i.getWidth();e.lineWidth=a!==void 0?a:_e;const r=i.getMiterLimit();e.miterLimit=r!==void 0?r:pe,e.lineWidth>this.maxLineWidth&&(this.maxLineWidth=e.lineWidth,this.bufferedMaxExtent_=null)}else e.strokeStyle=void 0,e.lineCap=void 0,e.lineDash=null,e.lineDashOffset=void 0,e.lineJoin=void 0,e.lineWidth=void 0,e.miterLimit=void 0}createFill(t){const i=t.fillStyle,e=[m.SET_FILL_STYLE,i];return typeof i!="string"&&e.push(!0),e}applyStroke(t){this.instructions.push(this.createStroke(t))}createStroke(t){return[m.SET_STROKE_STYLE,t.strokeStyle,t.lineWidth*this.pixelRatio,t.lineCap,t.lineJoin,t.miterLimit,this.applyPixelRatio(t.lineDash),t.lineDashOffset*this.pixelRatio]}updateFillStyle(t,i){const e=t.fillStyle;(typeof e!="string"||t.currentFillStyle!=e)&&(e!==void 0&&this.instructions.push(i.call(this,t)),t.currentFillStyle=e)}updateStrokeStyle(t,i){const e=t.strokeStyle,s=t.lineCap,n=t.lineDash,o=t.lineDashOffset,l=t.lineJoin,h=t.lineWidth,a=t.miterLimit;(t.currentStrokeStyle!=e||t.currentLineCap!=s||n!=t.currentLineDash&&!xe(t.currentLineDash,n)||t.currentLineDashOffset!=o||t.currentLineJoin!=l||t.currentLineWidth!=h||t.currentMiterLimit!=a)&&(e!==void 0&&i.call(this,t),t.currentStrokeStyle=e,t.currentLineCap=s,t.currentLineDash=n,t.currentLineDashOffset=o,t.currentLineJoin=l,t.currentLineWidth=h,t.currentMiterLimit=a)}endGeometry(t){this.beginGeometryInstruction1_[2]=this.instructions.length,this.beginGeometryInstruction1_=null,this.beginGeometryInstruction2_[2]=this.hitDetectionInstructions.length,this.beginGeometryInstruction2_=null;const i=[m.END_GEOMETRY,t];this.instructions.push(i),this.hitDetectionInstructions.push(i)}getBufferedMaxExtent(){if(!this.bufferedMaxExtent_&&(this.bufferedMaxExtent_=ve(this.maxExtent),this.maxLineWidth>0)){const t=this.resolution*(this.maxLineWidth+1)/2;Se(this.bufferedMaxExtent_,t,this.bufferedMaxExtent_)}return this.bufferedMaxExtent_}}const pt=$e;class Qe extends pt{constructor(t,i,e,s){super(t,i,e,s),this.hitDetectionImage_=null,this.image_=null,this.imagePixelRatio_=void 0,this.anchorX_=void 0,this.anchorY_=void 0,this.height_=void 0,this.opacity_=void 0,this.originX_=void 0,this.originY_=void 0,this.rotateWithView_=void 0,this.rotation_=void 0,this.scale_=void 0,this.width_=void 0,this.declutterMode_=void 0,this.declutterImageWithText_=void 0}drawPoint(t,i){if(!this.image_)return;this.beginGeometry(t,i);const e=t.getFlatCoordinates(),s=t.getStride(),n=this.coordinates.length,o=this.appendFlatPointCoordinates(e,s);this.instructions.push([m.DRAW_IMAGE,n,o,this.image_,this.anchorX_*this.imagePixelRatio_,this.anchorY_*this.imagePixelRatio_,Math.ceil(this.height_*this.imagePixelRatio_),this.opacity_,this.originX_*this.imagePixelRatio_,this.originY_*this.imagePixelRatio_,this.rotateWithView_,this.rotation_,[this.scale_[0]*this.pixelRatio/this.imagePixelRatio_,this.scale_[1]*this.pixelRatio/this.imagePixelRatio_],Math.ceil(this.width_*this.imagePixelRatio_),this.declutterMode_,this.declutterImageWithText_]),this.hitDetectionInstructions.push([m.DRAW_IMAGE,n,o,this.hitDetectionImage_,this.anchorX_,this.anchorY_,this.height_,1,this.originX_,this.originY_,this.rotateWithView_,this.rotation_,this.scale_,this.width_,this.declutterMode_,this.declutterImageWithText_]),this.endGeometry(i)}drawMultiPoint(t,i){if(!this.image_)return;this.beginGeometry(t,i);const e=t.getFlatCoordinates(),s=t.getStride(),n=this.coordinates.length,o=this.appendFlatPointCoordinates(e,s);this.instructions.push([m.DRAW_IMAGE,n,o,this.image_,this.anchorX_*this.imagePixelRatio_,this.anchorY_*this.imagePixelRatio_,Math.ceil(this.height_*this.imagePixelRatio_),this.opacity_,this.originX_*this.imagePixelRatio_,this.originY_*this.imagePixelRatio_,this.rotateWithView_,this.rotation_,[this.scale_[0]*this.pixelRatio/this.imagePixelRatio_,this.scale_[1]*this.pixelRatio/this.imagePixelRatio_],Math.ceil(this.width_*this.imagePixelRatio_),this.declutterMode_,this.declutterImageWithText_]),this.hitDetectionInstructions.push([m.DRAW_IMAGE,n,o,this.hitDetectionImage_,this.anchorX_,this.anchorY_,this.height_,1,this.originX_,this.originY_,this.rotateWithView_,this.rotation_,this.scale_,this.width_,this.declutterMode_,this.declutterImageWithText_]),this.endGeometry(i)}finish(){return this.reverseHitDetectionInstructions(),this.anchorX_=void 0,this.anchorY_=void 0,this.hitDetectionImage_=null,this.image_=null,this.imagePixelRatio_=void 0,this.height_=void 0,this.scale_=void 0,this.opacity_=void 0,this.originX_=void 0,this.originY_=void 0,this.rotateWithView_=void 0,this.rotation_=void 0,this.width_=void 0,super.finish()}setImageStyle(t,i){const e=t.getAnchor(),s=t.getSize(),n=t.getOrigin();this.imagePixelRatio_=t.getPixelRatio(this.pixelRatio),this.anchorX_=e[0],this.anchorY_=e[1],this.hitDetectionImage_=t.getHitDetectionImage(),this.image_=t.getImage(this.pixelRatio),this.height_=s[1],this.opacity_=t.getOpacity(),this.originX_=n[0],this.originY_=n[1],this.rotateWithView_=t.getRotateWithView(),this.rotation_=t.getRotation(),this.scale_=t.getScaleArray(),this.width_=s[0],this.declutterMode_=t.getDeclutterMode(),this.declutterImageWithText_=i}}const ti=Qe;class ei extends pt{constructor(t,i,e,s){super(t,i,e,s)}drawFlatCoordinates_(t,i,e,s){const n=this.coordinates.length,o=this.appendFlatLineCoordinates(t,i,e,s,!1,!1),l=[m.MOVE_TO_LINE_TO,n,o];return this.instructions.push(l),this.hitDetectionInstructions.push(l),e}drawLineString(t,i){const e=this.state,s=e.strokeStyle,n=e.lineWidth;if(s===void 0||n===void 0)return;this.updateStrokeStyle(e,this.applyStroke),this.beginGeometry(t,i),this.hitDetectionInstructions.push([m.SET_STROKE_STYLE,e.strokeStyle,e.lineWidth,e.lineCap,e.lineJoin,e.miterLimit,st,nt],it);const o=t.getFlatCoordinates(),l=t.getStride();this.drawFlatCoordinates_(o,0,o.length,l),this.hitDetectionInstructions.push(tt),this.endGeometry(i)}drawMultiLineString(t,i){const e=this.state,s=e.strokeStyle,n=e.lineWidth;if(s===void 0||n===void 0)return;this.updateStrokeStyle(e,this.applyStroke),this.beginGeometry(t,i),this.hitDetectionInstructions.push([m.SET_STROKE_STYLE,e.strokeStyle,e.lineWidth,e.lineCap,e.lineJoin,e.miterLimit,st,nt],it);const o=t.getEnds(),l=t.getFlatCoordinates(),h=t.getStride();let a=0;for(let r=0,d=o.length;r<d;++r)a=this.drawFlatCoordinates_(l,a,o[r],h);this.hitDetectionInstructions.push(tt),this.endGeometry(i)}finish(){const t=this.state;return t.lastStroke!=null&&t.lastStroke!=this.coordinates.length&&this.instructions.push(tt),this.reverseHitDetectionInstructions(),this.state=null,super.finish()}applyStroke(t){t.lastStroke!=null&&t.lastStroke!=this.coordinates.length&&(this.instructions.push(tt),t.lastStroke=this.coordinates.length),t.lastStroke=0,super.applyStroke(t),this.instructions.push(it)}}const ii=ei;class si extends pt{constructor(t,i,e,s){super(t,i,e,s)}drawFlatCoordinatess_(t,i,e,s){const n=this.state,o=n.fillStyle!==void 0,l=n.strokeStyle!==void 0,h=e.length;this.instructions.push(it),this.hitDetectionInstructions.push(it);for(let a=0;a<h;++a){const r=e[a],d=this.coordinates.length,c=this.appendFlatLineCoordinates(t,i,r,s,!0,!l),u=[m.MOVE_TO_LINE_TO,d,c];this.instructions.push(u),this.hitDetectionInstructions.push(u),l&&(this.instructions.push(ae),this.hitDetectionInstructions.push(ae)),i=r}return o&&(this.instructions.push(Ct),this.hitDetectionInstructions.push(Ct)),l&&(this.instructions.push(tt),this.hitDetectionInstructions.push(tt)),i}drawCircle(t,i){const e=this.state,s=e.fillStyle,n=e.strokeStyle;if(s===void 0&&n===void 0)return;this.setFillStrokeStyles_(),this.beginGeometry(t,i),e.fillStyle!==void 0&&this.hitDetectionInstructions.push([m.SET_FILL_STYLE,j]),e.strokeStyle!==void 0&&this.hitDetectionInstructions.push([m.SET_STROKE_STYLE,e.strokeStyle,e.lineWidth,e.lineCap,e.lineJoin,e.miterLimit,st,nt]);const o=t.getFlatCoordinates(),l=t.getStride(),h=this.coordinates.length;this.appendFlatLineCoordinates(o,0,o.length,l,!1,!1);const a=[m.CIRCLE,h];this.instructions.push(it,a),this.hitDetectionInstructions.push(it,a),e.fillStyle!==void 0&&(this.instructions.push(Ct),this.hitDetectionInstructions.push(Ct)),e.strokeStyle!==void 0&&(this.instructions.push(tt),this.hitDetectionInstructions.push(tt)),this.endGeometry(i)}drawPolygon(t,i){const e=this.state,s=e.fillStyle,n=e.strokeStyle;if(s===void 0&&n===void 0)return;this.setFillStrokeStyles_(),this.beginGeometry(t,i),e.fillStyle!==void 0&&this.hitDetectionInstructions.push([m.SET_FILL_STYLE,j]),e.strokeStyle!==void 0&&this.hitDetectionInstructions.push([m.SET_STROKE_STYLE,e.strokeStyle,e.lineWidth,e.lineCap,e.lineJoin,e.miterLimit,st,nt]);const o=t.getEnds(),l=t.getOrientedFlatCoordinates(),h=t.getStride();this.drawFlatCoordinatess_(l,0,o,h),this.endGeometry(i)}drawMultiPolygon(t,i){const e=this.state,s=e.fillStyle,n=e.strokeStyle;if(s===void 0&&n===void 0)return;this.setFillStrokeStyles_(),this.beginGeometry(t,i),e.fillStyle!==void 0&&this.hitDetectionInstructions.push([m.SET_FILL_STYLE,j]),e.strokeStyle!==void 0&&this.hitDetectionInstructions.push([m.SET_STROKE_STYLE,e.strokeStyle,e.lineWidth,e.lineCap,e.lineJoin,e.miterLimit,st,nt]);const o=t.getEndss(),l=t.getOrientedFlatCoordinates(),h=t.getStride();let a=0;for(let r=0,d=o.length;r<d;++r)a=this.drawFlatCoordinatess_(l,a,o[r],h);this.endGeometry(i)}finish(){this.reverseHitDetectionInstructions(),this.state=null;const t=this.tolerance;if(t!==0){const i=this.coordinates;for(let e=0,s=i.length;e<s;++e)i[e]=Ye(i[e],t)}return super.finish()}setFillStrokeStyles_(){const t=this.state;t.fillStyle!==void 0&&this.updateFillStyle(t,this.createFill),t.strokeStyle!==void 0&&this.updateStrokeStyle(t,this.applyStroke)}}const re=si;function ni(S,t,i,e,s){const n=[];let o=i,l=0,h=t.slice(i,2);for(;l<S&&o+s<e;){const[a,r]=h.slice(-2),d=t[o+s],c=t[o+s+1],u=Math.sqrt((d-a)*(d-a)+(c-r)*(c-r));if(l+=u,l>=S){const f=(S-l+u)/u,x=V(a,d,f),_=V(r,c,f);h.push(x,_),n.push(h),h=[x,_],l==S&&(o+=s),l=0}else if(l<S)h.push(t[o+s],t[o+s+1]),o+=s;else{const f=u-l,x=V(a,d,f/u),_=V(r,c,f/u);h.push(x,_),n.push(h),h=[x,_],l=0,o+=s}}return l>0&&n.push(h),n}function oi(S,t,i,e,s){let n=i,o=i,l=0,h=0,a=i,r,d,c,u,f,x,_,p,I,y;for(d=i;d<e;d+=s){const C=t[d],k=t[d+1];f!==void 0&&(I=C-f,y=k-x,u=Math.sqrt(I*I+y*y),_!==void 0&&(h+=c,r=Math.acos((_*I+p*y)/(c*u)),r>S&&(h>l&&(l=h,n=a,o=d),h=0,a=d-s)),c=u,_=I,p=y),f=C,x=k}return h+=u,h>l?[a,d]:[n,o]}const Et={left:0,center:.5,right:1,top:0,middle:.5,hanging:.2,alphabetic:.8,ideographic:.8,bottom:1};class li extends pt{constructor(t,i,e,s){super(t,i,e,s),this.labels_=null,this.text_="",this.textOffsetX_=0,this.textOffsetY_=0,this.textRotateWithView_=void 0,this.textRotation_=0,this.textFillState_=null,this.fillStates={},this.fillStates[j]={fillStyle:j},this.textStrokeState_=null,this.strokeStates={},this.textState_={},this.textStates={},this.textKey_="",this.fillKey_="",this.strokeKey_="",this.declutterImageWithText_=void 0}finish(){const t=super.finish();return t.textStates=this.textStates,t.fillStates=this.fillStates,t.strokeStates=this.strokeStates,t}drawText(t,i){const e=this.textFillState_,s=this.textStrokeState_,n=this.textState_;if(this.text_===""||!n||!e&&!s)return;const o=this.coordinates;let l=o.length;const h=t.getType();let a=null,r=t.getStride();if(n.placement==="line"&&(h=="LineString"||h=="MultiLineString"||h=="Polygon"||h=="MultiPolygon")){if(!Nt(this.getBufferedMaxExtent(),t.getExtent()))return;let d;if(a=t.getFlatCoordinates(),h=="LineString")d=[a.length];else if(h=="MultiLineString")d=t.getEnds();else if(h=="Polygon")d=t.getEnds().slice(0,1);else if(h=="MultiPolygon"){const x=t.getEndss();d=[];for(let _=0,p=x.length;_<p;++_)d.push(x[_][0])}this.beginGeometry(t,i);const c=n.repeat,u=c?void 0:n.textAlign;let f=0;for(let x=0,_=d.length;x<_;++x){let p;c?p=ni(c*this.resolution,a,f,d[x],r):p=[a.slice(f,d[x])];for(let I=0,y=p.length;I<y;++I){const C=p[I];let k=0,R=C.length;if(u==null){const b=oi(n.maxAngle,C,0,C.length,2);k=b[0],R=b[1]}for(let b=k;b<R;b+=r)o.push(C[b],C[b+1]);const E=o.length;f=d[x],this.drawChars_(l,E),l=E}}this.endGeometry(i)}else{let d=n.overflow?null:[];switch(h){case"Point":case"MultiPoint":a=t.getFlatCoordinates();break;case"LineString":a=t.getFlatMidpoint();break;case"Circle":a=t.getCenter();break;case"MultiLineString":a=t.getFlatMidpoints(),r=2;break;case"Polygon":a=t.getFlatInteriorPoint(),n.overflow||d.push(a[2]/this.resolution),r=3;break;case"MultiPolygon":const p=t.getFlatInteriorPoints();a=[];for(let I=0,y=p.length;I<y;I+=3)n.overflow||d.push(p[I+2]/this.resolution),a.push(p[I],p[I+1]);if(a.length===0)return;r=2;break}const c=this.appendFlatPointCoordinates(a,r);if(c===l)return;if(d&&(c-l)/2!==a.length/r){let p=l/2;d=d.filter((I,y)=>{const C=o[(p+y)*2]===a[y*r]&&o[(p+y)*2+1]===a[y*r+1];return C||--p,C})}this.saveTextStates_(),(n.backgroundFill||n.backgroundStroke)&&(this.setFillStrokeStyle(n.backgroundFill,n.backgroundStroke),n.backgroundFill&&this.updateFillStyle(this.state,this.createFill),n.backgroundStroke&&(this.updateStrokeStyle(this.state,this.applyStroke),this.hitDetectionInstructions.push(this.createStroke(this.state)))),this.beginGeometry(t,i);let u=n.padding;if(u!=et&&(n.scale[0]<0||n.scale[1]<0)){let p=n.padding[0],I=n.padding[1],y=n.padding[2],C=n.padding[3];n.scale[0]<0&&(I=-I,C=-C),n.scale[1]<0&&(p=-p,y=-y),u=[p,I,y,C]}const f=this.pixelRatio;this.instructions.push([m.DRAW_IMAGE,l,c,null,NaN,NaN,NaN,1,0,0,this.textRotateWithView_,this.textRotation_,[1,1],NaN,void 0,this.declutterImageWithText_,u==et?et:u.map(function(p){return p*f}),!!n.backgroundFill,!!n.backgroundStroke,this.text_,this.textKey_,this.strokeKey_,this.fillKey_,this.textOffsetX_,this.textOffsetY_,d]);const x=1/f,_=this.state.fillStyle;n.backgroundFill&&(this.state.fillStyle=j,this.hitDetectionInstructions.push(this.createFill(this.state))),this.hitDetectionInstructions.push([m.DRAW_IMAGE,l,c,null,NaN,NaN,NaN,1,0,0,this.textRotateWithView_,this.textRotation_,[x,x],NaN,void 0,this.declutterImageWithText_,u,!!n.backgroundFill,!!n.backgroundStroke,this.text_,this.textKey_,this.strokeKey_,this.fillKey_?j:this.fillKey_,this.textOffsetX_,this.textOffsetY_,d]),n.backgroundFill&&(this.state.fillStyle=_,this.hitDetectionInstructions.push(this.createFill(this.state))),this.endGeometry(i)}}saveTextStates_(){const t=this.textStrokeState_,i=this.textState_,e=this.textFillState_,s=this.strokeKey_;t&&(s in this.strokeStates||(this.strokeStates[s]={strokeStyle:t.strokeStyle,lineCap:t.lineCap,lineDashOffset:t.lineDashOffset,lineWidth:t.lineWidth,lineJoin:t.lineJoin,miterLimit:t.miterLimit,lineDash:t.lineDash}));const n=this.textKey_;n in this.textStates||(this.textStates[n]={font:i.font,textAlign:i.textAlign||Bt,justify:i.justify,textBaseline:i.textBaseline||Pt,scale:i.scale});const o=this.fillKey_;e&&(o in this.fillStates||(this.fillStates[o]={fillStyle:e.fillStyle}))}drawChars_(t,i){const e=this.textStrokeState_,s=this.textState_,n=this.strokeKey_,o=this.textKey_,l=this.fillKey_;this.saveTextStates_();const h=this.pixelRatio,a=Et[s.textBaseline],r=this.textOffsetY_*h,d=this.text_,c=e?e.lineWidth*Math.abs(s.scale[0])/2:0;this.instructions.push([m.DRAW_CHARS,t,i,a,s.overflow,l,s.maxAngle,h,r,n,c*h,d,o,1]),this.hitDetectionInstructions.push([m.DRAW_CHARS,t,i,a,s.overflow,l&&j,s.maxAngle,h,r,n,c*h,d,o,1/h])}setTextStyle(t,i){let e,s,n;if(!t)this.text_="";else{const o=t.getFill();o?(s=this.textFillState_,s||(s={},this.textFillState_=s),s.fillStyle=bt(o.getColor()||j)):(s=null,this.textFillState_=s);const l=t.getStroke();if(!l)n=null,this.textStrokeState_=n;else{n=this.textStrokeState_,n||(n={},this.textStrokeState_=n);const f=l.getLineDash(),x=l.getLineDashOffset(),_=l.getWidth(),p=l.getMiterLimit();n.lineCap=l.getLineCap()||fe,n.lineDash=f?f.slice():st,n.lineDashOffset=x===void 0?nt:x,n.lineJoin=l.getLineJoin()||ge,n.lineWidth=_===void 0?_e:_,n.miterLimit=p===void 0?pe:p,n.strokeStyle=bt(l.getColor()||ue)}e=this.textState_;const h=t.getFont()||Ge;Ne(h);const a=t.getScaleArray();e.overflow=t.getOverflow(),e.font=h,e.maxAngle=t.getMaxAngle(),e.placement=t.getPlacement(),e.textAlign=t.getTextAlign(),e.repeat=t.getRepeat(),e.justify=t.getJustify(),e.textBaseline=t.getTextBaseline()||Pt,e.backgroundFill=t.getBackgroundFill(),e.backgroundStroke=t.getBackgroundStroke(),e.padding=t.getPadding()||et,e.scale=a===void 0?[1,1]:a;const r=t.getOffsetX(),d=t.getOffsetY(),c=t.getRotateWithView(),u=t.getRotation();this.text_=t.getText()||"",this.textOffsetX_=r===void 0?0:r,this.textOffsetY_=d===void 0?0:d,this.textRotateWithView_=c===void 0?!1:c,this.textRotation_=u===void 0?0:u,this.strokeKey_=n?(typeof n.strokeStyle=="string"?n.strokeStyle:ne(n.strokeStyle))+n.lineCap+n.lineDashOffset+"|"+n.lineWidth+n.lineJoin+n.miterLimit+"["+n.lineDash.join()+"]":"",this.textKey_=e.font+e.scale+(e.textAlign||"?")+(e.repeat||"?")+(e.justify||"?")+(e.textBaseline||"?"),this.fillKey_=s?typeof s.fillStyle=="string"?s.fillStyle:"|"+ne(s.fillStyle):""}this.declutterImageWithText_=i}}const hi={Circle:re,Default:pt,Image:ti,LineString:ii,Polygon:re,Text:li};class ai{constructor(t,i,e,s){this.tolerance_=t,this.maxExtent_=i,this.pixelRatio_=s,this.resolution_=e,this.buildersByZIndex_={}}finish(){const t={};for(const i in this.buildersByZIndex_){t[i]=t[i]||{};const e=this.buildersByZIndex_[i];for(const s in e){const n=e[s].finish();t[i][s]=n}}return t}getBuilder(t,i){const e=t!==void 0?t.toString():"0";let s=this.buildersByZIndex_[e];s===void 0&&(s={},this.buildersByZIndex_[e]=s);let n=s[i];if(n===void 0){const o=hi[i];n=new o(this.tolerance_,this.maxExtent_,this.resolution_,this.pixelRatio_),s[i]=n}return n}}const yi=ai;function ri(S,t,i,e,s,n,o,l,h,a,r,d){let c=S[t],u=S[t+1],f=0,x=0,_=0,p=0;function I(){f=c,x=u,t+=e,c=S[t],u=S[t+1],p+=_,_=Math.sqrt((c-f)*(c-f)+(u-x)*(u-x))}do I();while(t<i-e&&p+_<n);let y=_===0?0:(n-p)/_;const C=V(f,c,y),k=V(x,u,y),R=t-e,E=p,b=n+l*h(a,s,r);for(;t<i-e&&p+_<b;)I();y=_===0?0:(b-p)/_;const L=V(f,c,y),D=V(x,u,y);let A;if(d){const M=[C,k,L,D];Xe(M,0,4,2,d,M,M),A=M[0]>M[2]}else A=C>L;const F=Math.PI,O=[],K=R+e===t;t=R,_=0,p=E,c=S[t],u=S[t+1];let T;if(K){I(),T=Math.atan2(u-x,c-f),A&&(T+=T>0?-F:F);const M=(L+C)/2,W=(D+k)/2;return O[0]=[M,W,(b-n)/2,T,s],O}s=s.replace(/\n/g," ");for(let M=0,W=s.length;M<W;){I();let w=Math.atan2(u-x,c-f);if(A&&(w+=w>0?-F:F),T!==void 0){let J=w-T;if(J+=J>F?-2*F:J<-F?2*F:0,Math.abs(J)>o)return null}T=w;const B=M;let P=0;for(;M<W;++M){const J=A?W-M-1:M,ot=l*h(a,s[J],r);if(t+e<i&&p+_<n+P+ot/2)break;P+=ot}if(M===B)continue;const H=A?s.substring(W-B,W-M):s.substring(B,M);y=_===0?0:(n+P/2-p)/_;const g=V(f,c,y),Xt=V(x,u,y);O.push([g,Xt,P/2,w,H]),n+=P}return O}const ht=Ie(),$=[],U=[],q=[],Q=[];function ce(S){return S[3].declutterBox}const de=new RegExp("["+String.fromCharCode(1425)+"-"+String.fromCharCode(2303)+String.fromCharCode(64285)+"-"+String.fromCharCode(65023)+String.fromCharCode(65136)+"-"+String.fromCharCode(65276)+String.fromCharCode(67584)+"-"+String.fromCharCode(69631)+String.fromCharCode(124928)+"-"+String.fromCharCode(126975)+"]");function Ft(S,t){return t==="start"?t=de.test(S)?"right":"left":t==="end"&&(t=de.test(S)?"left":"right"),Et[t]}function ci(S,t,i){return i>0&&S.push(`
`,""),S.push(t,""),S}class di{constructor(t,i,e,s){this.overlaps=e,this.pixelRatio=i,this.resolution=t,this.alignFill_,this.instructions=s.instructions,this.coordinates=s.coordinates,this.coordinateCache_={},this.renderedTransform_=vt(),this.hitDetectionInstructions=s.hitDetectionInstructions,this.pixelCoordinates_=null,this.viewRotation_=0,this.fillStates=s.fillStates||{},this.strokeStates=s.strokeStates||{},this.textStates=s.textStates||{},this.widths_={},this.labels_={}}createLabel(t,i,e,s){const n=t+i+e+s;if(this.labels_[n])return this.labels_[n];const o=s?this.strokeStates[s]:null,l=e?this.fillStates[e]:null,h=this.textStates[i],a=this.pixelRatio,r=[h.scale[0]*a,h.scale[1]*a],d=Array.isArray(t),c=h.justify?Et[h.justify]:Ft(Array.isArray(t)?t[0]:t,h.textAlign||Bt),u=s&&o.lineWidth?o.lineWidth:0,f=d?t:t.split(`
`).reduce(ci,[]),{width:x,height:_,widths:p,heights:I,lineWidths:y}=Ke(h,f),C=x+u,k=[],R=(C+2)*r[0],E=(_+u)*r[1],b={width:R<0?Math.floor(R):Math.ceil(R),height:E<0?Math.floor(E):Math.ceil(E),contextInstructions:k};(r[0]!=1||r[1]!=1)&&k.push("scale",r),s&&(k.push("strokeStyle",o.strokeStyle),k.push("lineWidth",u),k.push("lineCap",o.lineCap),k.push("lineJoin",o.lineJoin),k.push("miterLimit",o.miterLimit),k.push("setLineDash",[o.lineDash]),k.push("lineDashOffset",o.lineDashOffset)),e&&k.push("fillStyle",l.fillStyle),k.push("textBaseline","middle"),k.push("textAlign","center");const L=.5-c;let D=c*C+L*u;const A=[],F=[];let O=0,K=0,T=0,M=0,W;for(let w=0,B=f.length;w<B;w+=2){const P=f[w];if(P===`
`){K+=O,O=0,D=c*C+L*u,++M;continue}const H=f[w+1]||h.font;H!==W&&(s&&A.push("font",H),e&&F.push("font",H),W=H),O=Math.max(O,I[T]);const g=[P,D+L*p[T]+c*(p[T]-y[M]),.5*(u+O)+K];D+=p[T],s&&A.push("strokeText",g),e&&F.push("fillText",g),++T}return Array.prototype.push.apply(k,A),Array.prototype.push.apply(k,F),this.labels_[n]=b,b}replayTextBackground_(t,i,e,s,n,o,l){t.beginPath(),t.moveTo.apply(t,i),t.lineTo.apply(t,e),t.lineTo.apply(t,s),t.lineTo.apply(t,n),t.lineTo.apply(t,i),o&&(this.alignFill_=o[2],this.fill_(t)),l&&(this.setStrokeStyle_(t,l),t.stroke())}calculateImageOrLabelDimensions_(t,i,e,s,n,o,l,h,a,r,d,c,u,f,x,_){l*=c[0],h*=c[1];let p=e-l,I=s-h;const y=n+a>t?t-a:n,C=o+r>i?i-r:o,k=f[3]+y*c[0]+f[1],R=f[0]+C*c[1]+f[2],E=p-f[3],b=I-f[0];(x||d!==0)&&($[0]=E,Q[0]=E,$[1]=b,U[1]=b,U[0]=E+k,q[0]=U[0],q[1]=b+R,Q[1]=q[1]);let L;return d!==0?(L=ye(vt(),e,s,1,1,d,-e,-s),ft(L,$),ft(L,U),ft(L,q),ft(L,Q),oe(Math.min($[0],U[0],q[0],Q[0]),Math.min($[1],U[1],q[1],Q[1]),Math.max($[0],U[0],q[0],Q[0]),Math.max($[1],U[1],q[1],Q[1]),ht)):oe(Math.min(E,E+k),Math.min(b,b+R),Math.max(E,E+k),Math.max(b,b+R),ht),u&&(p=Math.round(p),I=Math.round(I)),{drawImageX:p,drawImageY:I,drawImageW:y,drawImageH:C,originX:a,originY:r,declutterBox:{minX:ht[0],minY:ht[1],maxX:ht[2],maxY:ht[3],value:_},canvasTransform:L,scale:c}}replayImageOrLabel_(t,i,e,s,n,o,l){const h=!!(o||l),a=s.declutterBox,r=t.canvas,d=l?l[2]*s.scale[0]/2:0;return a.minX-d<=r.width/i&&a.maxX+d>=0&&a.minY-d<=r.height/i&&a.maxY+d>=0&&(h&&this.replayTextBackground_(t,$,U,q,Q,o,l),He(t,s.canvasTransform,n,e,s.originX,s.originY,s.drawImageW,s.drawImageH,s.drawImageX,s.drawImageY,s.scale)),!0}fill_(t){if(this.alignFill_){const i=ft(this.renderedTransform_,[0,0]),e=512*this.pixelRatio;t.save(),t.translate(i[0]%e,i[1]%e),t.rotate(this.viewRotation_)}t.fill(),this.alignFill_&&t.restore()}setStrokeStyle_(t,i){t.strokeStyle=i[1],t.lineWidth=i[2],t.lineCap=i[3],t.lineJoin=i[4],t.miterLimit=i[5],t.lineDashOffset=i[7],t.setLineDash(i[6])}drawLabelWithPointPlacement_(t,i,e,s){const n=this.textStates[i],o=this.createLabel(t,i,s,e),l=this.strokeStates[e],h=this.pixelRatio,a=Ft(Array.isArray(t)?t[0]:t,n.textAlign||Bt),r=Et[n.textBaseline||Pt],d=l&&l.lineWidth?l.lineWidth:0,c=o.width/h-2*n.scale[0],u=a*c+2*(.5-a)*d,f=r*o.height/h+2*(.5-r)*d;return{label:o,anchorX:u,anchorY:f}}execute_(t,i,e,s,n,o,l,h){let a;this.pixelCoordinates_&&xe(e,this.renderedTransform_)?a=this.pixelCoordinates_:(this.pixelCoordinates_||(this.pixelCoordinates_=[]),a=me(this.coordinates,0,this.coordinates.length,2,e,this.pixelCoordinates_),Je(this.renderedTransform_,e));let r=0;const d=s.length;let c=0,u,f,x,_,p,I,y,C,k,R,E,b,L=0,D=0,A=null,F=null;const O=this.coordinateCache_,K=this.viewRotation_,T=Math.round(Math.atan2(-e[1],e[0])*1e12)/1e12,M={context:t,pixelRatio:this.pixelRatio,resolution:this.resolution,rotation:K},W=this.instructions!=s||this.overlaps?0:200;let w,B,P,H;for(;r<d;){const g=s[r];switch(g[0]){case m.BEGIN_GEOMETRY:w=g[1],H=g[3],w.getGeometry()?l!==void 0&&!Nt(l,H.getExtent())?r=g[2]+1:++r:r=g[2];break;case m.BEGIN_PATH:L>W&&(this.fill_(t),L=0),D>W&&(t.stroke(),D=0),!L&&!D&&(t.beginPath(),_=NaN,p=NaN),++r;break;case m.CIRCLE:c=g[1];const J=a[c],ot=a[c+1],ke=a[c+2],Ce=a[c+3],Kt=ke-J,Ht=Ce-ot,Jt=Math.sqrt(Kt*Kt+Ht*Ht);t.moveTo(J+Jt,ot),t.arc(J,ot,Jt,0,2*Math.PI,!0),++r;break;case m.CLOSE_PATH:t.closePath(),++r;break;case m.CUSTOM:c=g[1],u=g[2];const be=g[3],Ee=g[4],jt=g.length==6?g[5]:void 0;M.geometry=be,M.feature=w,r in O||(O[r]=[]);const at=O[r];jt?jt(a,c,u,2,at):(at[0]=a[c],at[1]=a[c+1],at.length=2),Ee(at,M),++r;break;case m.DRAW_IMAGE:c=g[1],u=g[2],C=g[3],f=g[4],x=g[5];let Lt=g[6];const Le=g[7],Re=g[8],De=g[9],Vt=g[10];let Rt=g[11];const Te=g[12];let xt=g[13];const zt=g[14],rt=g[15];if(!C&&g.length>=20){k=g[19],R=g[20],E=g[21],b=g[22];const Y=this.drawLabelWithPointPlacement_(k,R,E,b);C=Y.label,g[3]=C;const lt=g[23];f=(Y.anchorX-lt)*this.pixelRatio,g[4]=f;const N=g[24];x=(Y.anchorY-N)*this.pixelRatio,g[5]=x,Lt=C.height,g[6]=Lt,xt=C.width,g[13]=xt}let Dt;g.length>25&&(Dt=g[25]);let Tt,St,yt;g.length>17?(Tt=g[16],St=g[17],yt=g[18]):(Tt=et,St=!1,yt=!1),Vt&&T?Rt+=K:!Vt&&!T&&(Rt-=K);let Me=0;for(;c<u;c+=2){if(Dt&&Dt[Me++]<xt/this.pixelRatio)continue;const Y=this.calculateImageOrLabelDimensions_(C.width,C.height,a[c],a[c+1],xt,Lt,f,x,Re,De,Rt,Te,n,Tt,St||yt,w),lt=[t,i,C,Y,Le,St?A:null,yt?F:null];if(h){if(zt==="none")continue;if(zt==="obstacle"){h.insert(Y.declutterBox);continue}else{let N,z;if(rt){const G=u-c;if(!rt[G]){rt[G]=lt;continue}if(N=rt[G],delete rt[G],z=ce(N),h.collides(z))continue}if(h.collides(Y.declutterBox))continue;N&&(h.insert(z),this.replayImageOrLabel_.apply(this,N)),h.insert(Y.declutterBox)}}this.replayImageOrLabel_.apply(this,lt)}++r;break;case m.DRAW_CHARS:const Zt=g[1],Ut=g[2],Mt=g[3],we=g[4];b=g[5];const Oe=g[6],qt=g[7],$t=g[8];E=g[9];const wt=g[10];k=g[11],R=g[12];const Qt=[g[13],g[13]],Ot=this.textStates[R],ct=Ot.font,dt=[Ot.scale[0]*qt,Ot.scale[1]*qt];let ut;ct in this.widths_?ut=this.widths_[ct]:(ut={},this.widths_[ct]=ut);const te=Ue(a,Zt,Ut,2),ee=Math.abs(dt[0])*le(ct,k,ut);if(we||ee<=te){const Y=this.textStates[R].textAlign,lt=(te-ee)*Ft(k,Y),N=ri(a,Zt,Ut,2,k,lt,Oe,Math.abs(dt[0]),le,ct,ut,T?0:this.viewRotation_);t:if(N){const z=[];let G,mt,It,v,X;if(E)for(G=0,mt=N.length;G<mt;++G){X=N[G],It=X[4],v=this.createLabel(It,R,"",E),f=X[2]+(dt[0]<0?-wt:wt),x=Mt*v.height+(.5-Mt)*2*wt*dt[1]/dt[0]-$t;const Z=this.calculateImageOrLabelDimensions_(v.width,v.height,X[0],X[1],v.width,v.height,f,x,0,0,X[3],Qt,!1,et,!1,w);if(h&&h.collides(Z.declutterBox))break t;z.push([t,i,v,Z,1,null,null])}if(b)for(G=0,mt=N.length;G<mt;++G){X=N[G],It=X[4],v=this.createLabel(It,R,b,""),f=X[2],x=Mt*v.height-$t;const Z=this.calculateImageOrLabelDimensions_(v.width,v.height,X[0],X[1],v.width,v.height,f,x,0,0,X[3],Qt,!1,et,!1,w);if(h&&h.collides(Z.declutterBox))break t;z.push([t,i,v,Z,1,null,null])}h&&h.load(z.map(ce));for(let Z=0,Fe=z.length;Z<Fe;++Z)this.replayImageOrLabel_.apply(this,z[Z])}}++r;break;case m.END_GEOMETRY:if(o!==void 0){w=g[1];const Y=o(w,H);if(Y)return Y}++r;break;case m.FILL:W?L++:this.fill_(t),++r;break;case m.MOVE_TO_LINE_TO:for(c=g[1],u=g[2],B=a[c],P=a[c+1],I=B+.5|0,y=P+.5|0,(I!==_||y!==p)&&(t.moveTo(B,P),_=I,p=y),c+=2;c<u;c+=2)B=a[c],P=a[c+1],I=B+.5|0,y=P+.5|0,(c==u-2||I!==_||y!==p)&&(t.lineTo(B,P),_=I,p=y);++r;break;case m.SET_FILL_STYLE:A=g,this.alignFill_=g[2],L&&(this.fill_(t),L=0,D&&(t.stroke(),D=0)),t.fillStyle=g[1],++r;break;case m.SET_STROKE_STYLE:F=g,D&&(t.stroke(),D=0),this.setStrokeStyle_(t,g),++r;break;case m.STROKE:W?D++:t.stroke(),++r;break;default:++r;break}}L&&this.fill_(t),D&&t.stroke()}execute(t,i,e,s,n,o){this.viewRotation_=s,this.execute_(t,i,e,this.instructions,n,void 0,void 0,o)}executeHitDetection(t,i,e,s,n){return this.viewRotation_=e,this.execute_(t,1,i,this.hitDetectionInstructions,!0,s,n)}}const ui=di,Wt=["Polygon","Circle","LineString","Image","Text","Default"];class fi{constructor(t,i,e,s,n,o){this.maxExtent_=t,this.overlaps_=s,this.pixelRatio_=e,this.resolution_=i,this.renderBuffer_=o,this.executorsByZIndex_={},this.hitDetectionContext_=null,this.hitDetectionTransform_=vt(),this.createExecutors_(n)}clip(t,i){const e=this.getClipCoords(i);t.beginPath(),t.moveTo(e[0],e[1]),t.lineTo(e[2],e[3]),t.lineTo(e[4],e[5]),t.lineTo(e[6],e[7]),t.clip()}createExecutors_(t){for(const i in t){let e=this.executorsByZIndex_[i];e===void 0&&(e={},this.executorsByZIndex_[i]=e);const s=t[i];for(const n in s){const o=s[n];e[n]=new ui(this.resolution_,this.pixelRatio_,this.overlaps_,o)}}}hasExecutors(t){for(const i in this.executorsByZIndex_){const e=this.executorsByZIndex_[i];for(let s=0,n=t.length;s<n;++s)if(t[s]in e)return!0}return!1}forEachFeatureAtCoordinate(t,i,e,s,n,o){s=Math.round(s);const l=s*2+1,h=ye(this.hitDetectionTransform_,s+.5,s+.5,1/i,-1/i,-e,-t[0],-t[1]),a=!this.hitDetectionContext_;a&&(this.hitDetectionContext_=Yt(l,l,void 0,{willReadFrequently:!0}));const r=this.hitDetectionContext_;r.canvas.width!==l||r.canvas.height!==l?(r.canvas.width=l,r.canvas.height=l):a||r.clearRect(0,0,l,l);let d;this.renderBuffer_!==void 0&&(d=Ie(),je(d,t),Se(d,i*(this.renderBuffer_+s),d));const c=gi(s);let u;function f(k,R){const E=r.getImageData(0,0,l,l).data;for(let b=0,L=c.length;b<L;b++)if(E[c[b]]>0){if(!o||u!=="Image"&&u!=="Text"||o.includes(k)){const D=(c[b]-3)/4,A=s-D%l,F=s-(D/l|0),O=n(k,R,A*A+F*F);if(O)return O}r.clearRect(0,0,l,l);break}}const x=Object.keys(this.executorsByZIndex_).map(Number);x.sort(Gt);let _,p,I,y,C;for(_=x.length-1;_>=0;--_){const k=x[_].toString();for(I=this.executorsByZIndex_[k],p=Wt.length-1;p>=0;--p)if(u=Wt[p],y=I[u],y!==void 0&&(C=y.executeHitDetection(r,h,e,f,d),C))return C}}getClipCoords(t){const i=this.maxExtent_;if(!i)return null;const e=i[0],s=i[1],n=i[2],o=i[3],l=[e,s,e,o,n,o,n,s];return me(l,0,8,2,t,l),l}isEmpty(){return Ve(this.executorsByZIndex_)}execute(t,i,e,s,n,o,l){const h=Object.keys(this.executorsByZIndex_).map(Number);h.sort(Gt),this.maxExtent_&&(t.save(),this.clip(t,e)),o=o||Wt;let a,r,d,c,u,f;for(l&&h.reverse(),a=0,r=h.length;a<r;++a){const x=h[a].toString();for(u=this.executorsByZIndex_[x],d=0,c=o.length;d<c;++d){const _=o[d];f=u[_],f!==void 0&&f.execute(t,i,e,s,n,l)}}this.maxExtent_&&t.restore()}}const At={};function gi(S){if(At[S]!==void 0)return At[S];const t=S*2+1,i=S*S,e=new Array(i+1);for(let n=0;n<=S;++n)for(let o=0;o<=S;++o){const l=n*n+o*o;if(l>i)break;let h=e[l];h||(h=[],e[l]=h),h.push(((S+n)*t+(S+o))*4+3),n>0&&h.push(((S-n)*t+(S+o))*4+3),o>0&&(h.push(((S+n)*t+(S-o))*4+3),n>0&&h.push(((S-n)*t+(S-o))*4+3))}const s=[];for(let n=0,o=e.length;n<o;++n)e[n]&&s.push(...e[n]);return At[S]=s,s}const mi=fi,gt=.5;function Ii(S,t,i,e,s,n,o){const l=S[0]*gt,h=S[1]*gt,a=Yt(l,h);a.imageSmoothingEnabled=!1;const r=a.canvas,d=new Ze(a,gt,s,null,o),c=i.length,u=Math.floor((256*256*256-1)/c),f={};for(let _=1;_<=c;++_){const p=i[_-1],I=p.getStyleFunction()||e;if(!I)continue;let y=I(p,n);if(!y)continue;Array.isArray(y)||(y=[y]);const k=(_*u).toString(16).padStart(7,"#00000");for(let R=0,E=y.length;R<E;++R){const b=y[R],L=b.getGeometryFunction()(p);if(!L||!Nt(s,L.getExtent()))continue;const D=b.clone(),A=D.getFill();A&&A.setColor(k);const F=D.getStroke();F&&(F.setColor(k),F.setLineDash(null)),D.setText(void 0);const O=b.getImage();if(O){const W=O.getImageSize();if(!W)continue;const w=Yt(W[0],W[1],void 0,{alpha:!1}),B=w.canvas;w.fillStyle=k,w.fillRect(0,0,B.width,B.height),D.setImage(new qe({img:B,anchor:O.getAnchor(),anchorXUnits:"pixels",anchorYUnits:"pixels",offset:O.getOrigin(),opacity:1,size:O.getSize(),scale:O.getScale(),rotation:O.getRotation(),rotateWithView:O.getRotateWithView()}))}const K=D.getZIndex()||0;let T=f[K];T||(T={},f[K]=T,T.Polygon=[],T.Circle=[],T.LineString=[],T.Point=[]);const M=L.getType();if(M==="GeometryCollection"){const W=L.getGeometriesArrayRecursive();for(let w=0,B=W.length;w<B;++w){const P=W[w];T[P.getType().replace("Multi","")].push(P,D)}}else T[M.replace("Multi","")].push(L,D)}}const x=Object.keys(f).map(Number).sort(Gt);for(let _=0,p=x.length;_<p;++_){const I=f[x[_]];for(const y in I){const C=I[y];for(let k=0,R=C.length;k<R;k+=2){d.setStyle(C[k+1]);for(let E=0,b=t.length;E<b;++E)d.setTransform(t[E]),d.drawGeometry(C[k])}}}return a.getImageData(0,0,r.width,r.height)}function ki(S,t,i){const e=[];if(i){const s=Math.floor(Math.round(S[0])*gt),n=Math.floor(Math.round(S[1])*gt),o=(he(s,0,i.width-1)+he(n,0,i.height-1)*i.width)*4,l=i.data[o],h=i.data[o+1],r=i.data[o+2]+256*(h+256*l),d=Math.floor((256*256*256-1)/t.length);r&&r%d===0&&e.push(t[r/d-1])}return e}export{yi as C,mi as E,gt as H,Ii as c,ki as h};
