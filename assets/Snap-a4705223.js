import{T as X,cI as ie,cJ as ne,cd as se,cK as re,bV as N,bX as D,H as j,m as x,aK as L,P as O,cH as w,cL as U,cM as m,a1 as E,cN as C,v as b,$ as oe,x as J,aS as Q,cO as F,aG as ae,cP as Z,aD as z,cQ as he,bZ as le,cR as ue,W as ce,K as M,N as B,cS as ge,cT as de}from"./Layer-227d2e40.js";import{R as ee,V as fe,a as R,F as q}from"./Vector-dc05cca5.js";import{V as _e}from"./Vector-1db23811.js";import{d as me}from"./Style-f78957a3.js";const K=0,T=1,H=[0,0,0,0],v=[],A={MODIFYSTART:"modifystart",MODIFYEND:"modifyend"};class V extends z{constructor(e,t,n){super(e),this.features=t,this.mapBrowserEvent=n}}class ye extends X{constructor(e){super(e),this.on,this.once,this.un,this.boundHandleFeatureChange_=this.handleFeatureChange_.bind(this),this.condition_=e.condition?e.condition:ie,this.defaultDeleteCondition_=function(n){return ne(n)&&se(n)},this.deleteCondition_=e.deleteCondition?e.deleteCondition:this.defaultDeleteCondition_,this.insertVertexCondition_=e.insertVertexCondition?e.insertVertexCondition:re,this.vertexFeature_=null,this.vertexSegments_=null,this.lastPixel_=[0,0],this.ignoreNextSingleClick_=!1,this.featuresBeingModified_=null,this.rBush_=new ee,this.pixelTolerance_=e.pixelTolerance!==void 0?e.pixelTolerance:10,this.snappedToVertex_=!1,this.changingFeature_=!1,this.dragSegments_=[],this.overlay_=new _e({source:new fe({useSpatialIndex:!1,wrapX:!!e.wrapX}),style:e.style?e.style:pe(),updateWhileAnimating:!0,updateWhileInteracting:!0}),this.SEGMENT_WRITERS_={Point:this.writePointGeometry_.bind(this),LineString:this.writeLineStringGeometry_.bind(this),LinearRing:this.writeLineStringGeometry_.bind(this),Polygon:this.writePolygonGeometry_.bind(this),MultiPoint:this.writeMultiPointGeometry_.bind(this),MultiLineString:this.writeMultiLineStringGeometry_.bind(this),MultiPolygon:this.writeMultiPolygonGeometry_.bind(this),Circle:this.writeCircleGeometry_.bind(this),GeometryCollection:this.writeGeometryCollectionGeometry_.bind(this)},this.source_=null,this.hitDetection_=null;let t;if(e.features?t=e.features:e.source&&(this.source_=e.source,t=new N(this.source_.getFeatures()),this.source_.addEventListener(R.ADDFEATURE,this.handleSourceAdd_.bind(this)),this.source_.addEventListener(R.REMOVEFEATURE,this.handleSourceRemove_.bind(this))),!t)throw new Error("The modify interaction requires features, a source or a layer");e.hitDetection&&(this.hitDetection_=e.hitDetection),this.features_=t,this.features_.forEach(this.addFeature_.bind(this)),this.features_.addEventListener(D.ADD,this.handleFeatureAdd_.bind(this)),this.features_.addEventListener(D.REMOVE,this.handleFeatureRemove_.bind(this)),this.lastPointerEvent_=null,this.delta_=[0,0],this.snapToPointer_=e.snapToPointer===void 0?!this.hitDetection_:e.snapToPointer}addFeature_(e){const t=e.getGeometry();if(t){const i=this.SEGMENT_WRITERS_[t.getType()];i&&i(e,t)}const n=this.getMap();n&&n.isRendered()&&this.getActive()&&this.handlePointerAtPixel_(this.lastPixel_,n),e.addEventListener(j.CHANGE,this.boundHandleFeatureChange_)}willModifyFeatures_(e,t){if(!this.featuresBeingModified_){this.featuresBeingModified_=new N;const n=this.featuresBeingModified_.getArray();for(let i=0,s=t.length;i<s;++i){const r=t[i];for(let a=0,o=r.length;a<o;++a){const h=r[a].feature;h&&!n.includes(h)&&this.featuresBeingModified_.push(h)}}this.featuresBeingModified_.getLength()===0?this.featuresBeingModified_=null:this.dispatchEvent(new V(A.MODIFYSTART,this.featuresBeingModified_,e))}}removeFeature_(e){this.removeFeatureSegmentData_(e),this.vertexFeature_&&this.features_.getLength()===0&&(this.overlay_.getSource().removeFeature(this.vertexFeature_),this.vertexFeature_=null),e.removeEventListener(j.CHANGE,this.boundHandleFeatureChange_)}removeFeatureSegmentData_(e){const t=this.rBush_,n=[];t.forEach(function(i){e===i.feature&&n.push(i)});for(let i=n.length-1;i>=0;--i){const s=n[i];for(let r=this.dragSegments_.length-1;r>=0;--r)this.dragSegments_[r][0]===s&&this.dragSegments_.splice(r,1);t.remove(s)}}setActive(e){this.vertexFeature_&&!e&&(this.overlay_.getSource().removeFeature(this.vertexFeature_),this.vertexFeature_=null),super.setActive(e)}setMap(e){this.overlay_.setMap(e),super.setMap(e)}getOverlay(){return this.overlay_}handleSourceAdd_(e){e.feature&&this.features_.push(e.feature)}handleSourceRemove_(e){e.feature&&this.features_.remove(e.feature)}handleFeatureAdd_(e){this.addFeature_(e.element)}handleFeatureChange_(e){if(!this.changingFeature_){const t=e.target;this.removeFeature_(t),this.addFeature_(t)}}handleFeatureRemove_(e){this.removeFeature_(e.element)}writePointGeometry_(e,t){const n=t.getCoordinates(),i={feature:e,geometry:t,segment:[n,n]};this.rBush_.insert(t.getExtent(),i)}writeMultiPointGeometry_(e,t){const n=t.getCoordinates();for(let i=0,s=n.length;i<s;++i){const r=n[i],a={feature:e,geometry:t,depth:[i],index:i,segment:[r,r]};this.rBush_.insert(t.getExtent(),a)}}writeLineStringGeometry_(e,t){const n=t.getCoordinates();for(let i=0,s=n.length-1;i<s;++i){const r=n.slice(i,i+2),a={feature:e,geometry:t,index:i,segment:r};this.rBush_.insert(x(r),a)}}writeMultiLineStringGeometry_(e,t){const n=t.getCoordinates();for(let i=0,s=n.length;i<s;++i){const r=n[i];for(let a=0,o=r.length-1;a<o;++a){const h=r.slice(a,a+2),u={feature:e,geometry:t,depth:[i],index:a,segment:h};this.rBush_.insert(x(h),u)}}}writePolygonGeometry_(e,t){const n=t.getCoordinates();for(let i=0,s=n.length;i<s;++i){const r=n[i];for(let a=0,o=r.length-1;a<o;++a){const h=r.slice(a,a+2),u={feature:e,geometry:t,depth:[i],index:a,segment:h};this.rBush_.insert(x(h),u)}}}writeMultiPolygonGeometry_(e,t){const n=t.getCoordinates();for(let i=0,s=n.length;i<s;++i){const r=n[i];for(let a=0,o=r.length;a<o;++a){const h=r[a];for(let u=0,c=h.length-1;u<c;++u){const d=h.slice(u,u+2),l={feature:e,geometry:t,depth:[a,i],index:u,segment:d};this.rBush_.insert(x(d),l)}}}}writeCircleGeometry_(e,t){const n=t.getCenter(),i={feature:e,geometry:t,index:K,segment:[n,n]},s={feature:e,geometry:t,index:T,segment:[n,n]},r=[i,s];i.featureSegments=r,s.featureSegments=r,this.rBush_.insert(L(n),i);let a=t;this.rBush_.insert(a.getExtent(),s)}writeGeometryCollectionGeometry_(e,t){const n=t.getGeometriesArray();for(let i=0;i<n.length;++i){const s=n[i],r=this.SEGMENT_WRITERS_[s.getType()];r(e,s)}}createOrUpdateVertexFeature_(e,t,n){let i=this.vertexFeature_;return i?i.getGeometry().setCoordinates(e):(i=new q(new O(e)),this.vertexFeature_=i,this.overlay_.getSource().addFeature(i)),i.set("features",t),i.set("geometries",n),i}handleEvent(e){if(!e.originalEvent)return!0;this.lastPointerEvent_=e;let t;return!e.map.getView().getInteracting()&&e.type==w.POINTERMOVE&&!this.handlingDownUpSequence&&this.handlePointerMove_(e),this.vertexFeature_&&this.deleteCondition_(e)&&(e.type!=w.SINGLECLICK||!this.ignoreNextSingleClick_?t=this.removePoint():t=!0),e.type==w.SINGLECLICK&&(this.ignoreNextSingleClick_=!1),super.handleEvent(e)&&!t}handleDragEvent(e){this.ignoreNextSingleClick_=!1,this.willModifyFeatures_(e,this.dragSegments_);const t=[e.coordinate[0]+this.delta_[0],e.coordinate[1]+this.delta_[1]],n=[],i=[];for(let s=0,r=this.dragSegments_.length;s<r;++s){const a=this.dragSegments_[s],o=a[0],h=o.feature;n.includes(h)||n.push(h);const u=o.geometry;i.includes(u)||i.push(u);const c=o.depth;let d;const l=o.segment,g=a[1];for(;t.length<u.getStride();)t.push(l[g][t.length]);switch(u.getType()){case"Point":d=t,l[0]=t,l[1]=t;break;case"MultiPoint":d=u.getCoordinates(),d[o.index]=t,l[0]=t,l[1]=t;break;case"LineString":d=u.getCoordinates(),d[o.index+g]=t,l[g]=t;break;case"MultiLineString":d=u.getCoordinates(),d[c[0]][o.index+g]=t,l[g]=t;break;case"Polygon":d=u.getCoordinates(),d[c[0]][o.index+g]=t,l[g]=t;break;case"MultiPolygon":d=u.getCoordinates(),d[c[1]][c[0]][o.index+g]=t,l[g]=t;break;case"Circle":if(l[0]=t,l[1]=t,o.index===K)this.changingFeature_=!0,u.setCenter(t),this.changingFeature_=!1;else{this.changingFeature_=!0,e.map.getView().getProjection();let f=U(m(u.getCenter()),m(t));u.setRadius(f),this.changingFeature_=!1}break}d&&this.setGeometryCoordinates_(u,d)}this.createOrUpdateVertexFeature_(t,n,i)}handleDownEvent(e){if(!this.condition_(e))return!1;const t=e.coordinate;this.handlePointerAtPixel_(e.pixel,e.map,t),this.dragSegments_.length=0,this.featuresBeingModified_=null;const n=this.vertexFeature_;if(n){e.map.getView().getProjection();const i=[],s=n.getGeometry().getCoordinates(),r=x([s]),a=this.rBush_.getInExtent(r),o={};a.sort(xe);for(let h=0,u=a.length;h<u;++h){const c=a[h],d=c.segment;let l=E(c.geometry);const g=c.depth;if(g&&(l+="-"+g.join("-")),o[l]||(o[l]=new Array(2)),c.geometry.getType()==="Circle"&&c.index===T){const f=W(t,c);C(f,s)&&!o[l][0]&&(this.dragSegments_.push([c,0]),o[l][0]=c);continue}if(C(d[0],s)&&!o[l][0]){this.dragSegments_.push([c,0]),o[l][0]=c;continue}if(C(d[1],s)&&!o[l][1]){if(o[l][0]&&o[l][0].index===0){let f=c.geometry.getCoordinates();switch(c.geometry.getType()){case"LineString":case"MultiLineString":continue;case"MultiPolygon":f=f[g[1]];case"Polygon":if(c.index!==f[g[0]].length-2)continue;break}}this.dragSegments_.push([c,1]),o[l][1]=c;continue}E(d)in this.vertexSegments_&&!o[l][0]&&!o[l][1]&&this.insertVertexCondition_(e)&&i.push(c)}i.length&&this.willModifyFeatures_(e,[i]);for(let h=i.length-1;h>=0;--h)this.insertVertex_(i[h],s)}return!!this.vertexFeature_}handleUpEvent(e){for(let t=this.dragSegments_.length-1;t>=0;--t){const n=this.dragSegments_[t][0],i=n.geometry;if(i.getType()==="Circle"){const s=i.getCenter(),r=n.featureSegments[0],a=n.featureSegments[1];r.segment[0]=s,r.segment[1]=s,a.segment[0]=s,a.segment[1]=s,this.rBush_.update(L(s),r);let o=i;this.rBush_.update(o.getExtent(),a)}else this.rBush_.update(x(n.segment),n)}return this.featuresBeingModified_&&(this.dispatchEvent(new V(A.MODIFYEND,this.featuresBeingModified_,e)),this.featuresBeingModified_=null),!1}handlePointerMove_(e){this.lastPixel_=e.pixel,this.handlePointerAtPixel_(e.pixel,e.map,e.coordinate)}handlePointerAtPixel_(e,t,n){const i=n||t.getCoordinateFromPixel(e);t.getView().getProjection();const s=function(o,h){return Y(i,o)-Y(i,h)};let r,a;if(this.hitDetection_){const o=typeof this.hitDetection_=="object"?h=>h===this.hitDetection_:void 0;t.forEachFeatureAtPixel(e,(h,u,c)=>{c&&(c=new O(b(c.getCoordinates())));const d=c||h.getGeometry();if(d.getType()==="Point"&&h instanceof q&&this.features_.getArray().includes(h)){a=d;const l=h.getGeometry().getFlatCoordinates().slice(0,2);r=[{feature:h,geometry:a,segment:[l,l]}]}return!0},{layerFilter:o})}if(!r){const o=oe(L(i,H)),h=t.getView().getResolution()*this.pixelTolerance_,u=J(Q(o,h,H));r=this.rBush_.getInExtent(u)}if(r&&r.length>0){const o=r.sort(s)[0],h=o.segment;let u=W(i,o);const c=t.getPixelFromCoordinate(u);let d=U(e,c);if(a||d<=this.pixelTolerance_){const l={};if(l[E(h)]=!0,this.snapToPointer_||(this.delta_[0]=u[0]-i[0],this.delta_[1]=u[1]-i[1]),o.geometry.getType()==="Circle"&&o.index===T)this.snappedToVertex_=!0,this.createOrUpdateVertexFeature_(u,[o.feature],[o.geometry]);else{const g=t.getPixelFromCoordinate(h[0]),f=t.getPixelFromCoordinate(h[1]),y=F(c,g),p=F(c,f);d=Math.sqrt(Math.min(y,p)),this.snappedToVertex_=d<=this.pixelTolerance_,this.snappedToVertex_&&(u=y>p?h[1]:h[0]),this.createOrUpdateVertexFeature_(u,[o.feature],[o.geometry]);const S={};S[E(o.geometry)]=!0;for(let G=1,te=r.length;G<te;++G){const P=r[G].segment;if(C(h[0],P[0])&&C(h[1],P[1])||C(h[0],P[1])&&C(h[1],P[0])){const k=E(r[G].geometry);k in S||(S[k]=!0,l[E(P)]=!0)}else break}}this.vertexSegments_=l;return}}this.vertexFeature_&&(this.overlay_.getSource().removeFeature(this.vertexFeature_),this.vertexFeature_=null)}insertVertex_(e,t){const n=e.segment,i=e.feature,s=e.geometry,r=e.depth,a=e.index;let o;for(;t.length<s.getStride();)t.push(0);switch(s.getType()){case"MultiLineString":o=s.getCoordinates(),o[r[0]].splice(a+1,0,t);break;case"Polygon":o=s.getCoordinates(),o[r[0]].splice(a+1,0,t);break;case"MultiPolygon":o=s.getCoordinates(),o[r[1]][r[0]].splice(a+1,0,t);break;case"LineString":o=s.getCoordinates(),o.splice(a+1,0,t);break;default:return}this.setGeometryCoordinates_(s,o);const h=this.rBush_;h.remove(e),this.updateSegmentIndices_(s,a,r,1);const u={segment:[n[0],t],feature:i,geometry:s,depth:r,index:a};h.insert(x(u.segment),u),this.dragSegments_.push([u,1]);const c={segment:[t,n[1]],feature:i,geometry:s,depth:r,index:a+1};h.insert(x(c.segment),c),this.dragSegments_.push([c,0]),this.ignoreNextSingleClick_=!0}removePoint(){if(this.lastPointerEvent_&&this.lastPointerEvent_.type!=w.POINTERDRAG){const e=this.lastPointerEvent_;this.willModifyFeatures_(e,this.dragSegments_);const t=this.removeVertex_();return this.featuresBeingModified_&&this.dispatchEvent(new V(A.MODIFYEND,this.featuresBeingModified_,e)),this.featuresBeingModified_=null,t}return!1}removeVertex_(){const e=this.dragSegments_,t={};let n=!1,i,s,r,a,o,h,u,c,d,l,g;for(o=e.length-1;o>=0;--o)r=e[o],l=r[0],g=E(l.feature),l.depth&&(g+="-"+l.depth.join("-")),g in t||(t[g]={}),r[1]===0?(t[g].right=l,t[g].index=l.index):r[1]==1&&(t[g].left=l,t[g].index=l.index+1);for(g in t){switch(d=t[g].right,u=t[g].left,h=t[g].index,c=h-1,u!==void 0?l=u:l=d,c<0&&(c=0),a=l.geometry,s=a.getCoordinates(),i=s,n=!1,a.getType()){case"MultiLineString":s[l.depth[0]].length>2&&(s[l.depth[0]].splice(h,1),n=!0);break;case"LineString":s.length>2&&(s.splice(h,1),n=!0);break;case"MultiPolygon":i=i[l.depth[1]];case"Polygon":i=i[l.depth[0]],i.length>4&&(h==i.length-1&&(h=0),i.splice(h,1),n=!0,h===0&&(i.pop(),i.push(i[0]),c=i.length-1));break}if(n){this.setGeometryCoordinates_(a,s);const f=[];if(u!==void 0&&(this.rBush_.remove(u),f.push(u.segment[0])),d!==void 0&&(this.rBush_.remove(d),f.push(d.segment[1])),u!==void 0&&d!==void 0){const y={depth:l.depth,feature:l.feature,geometry:l.geometry,index:c,segment:f};this.rBush_.insert(x(y.segment),y)}this.updateSegmentIndices_(a,h,l.depth,-1),this.vertexFeature_&&(this.overlay_.getSource().removeFeature(this.vertexFeature_),this.vertexFeature_=null),e.length=0}}return n}setGeometryCoordinates_(e,t){this.changingFeature_=!0,e.setCoordinates(t),this.changingFeature_=!1}updateSegmentIndices_(e,t,n,i){this.rBush_.forEachInExtent(e.getExtent(),function(s){s.geometry===e&&(n===void 0||s.depth===void 0||ae(s.depth,n))&&s.index>t&&(s.index+=i)})}}function xe(_,e){return _.index-e.index}function Y(_,e,t){const n=e.geometry;if(n.getType()==="Circle"){let s=n;if(e.index===T){const r=F(s.getCenter(),m(_)),a=Math.sqrt(r)-s.getRadius();return a*a}}const i=m(_);return v[0]=m(e.segment[0]),v[1]=m(e.segment[1]),he(i,v)}function W(_,e,t){const n=e.geometry;if(n.getType()==="Circle"&&e.index===T)return b(n.getClosestPoint(m(_)));const i=m(_);return v[0]=m(e.segment[0]),v[1]=m(e.segment[1]),b(Z(i,v))}function pe(){const _=me();return function(e,t){return _.Point}}const Te=ye,Ee={SNAP:"snap"};class Se extends z{constructor(e,t){super(e),this.vertex=t.vertex,this.vertexPixel=t.vertexPixel,this.feature=t.feature}}function $(_){return _.feature?_.feature:_.element?_.element:null}const I=[];class Ce extends X{constructor(e){e=e||{};const t=e;t.handleDownEvent||(t.handleDownEvent=le),t.stopDown||(t.stopDown=ue),super(t),this.on,this.once,this.un,this.source_=e.source?e.source:null,this.vertex_=e.vertex!==void 0?e.vertex:!0,this.edge_=e.edge!==void 0?e.edge:!0,this.features_=e.features?e.features:null,this.featuresListenerKeys_=[],this.featureChangeListenerKeys_={},this.indexedFeaturesExtents_={},this.pendingFeatures_={},this.pixelTolerance_=e.pixelTolerance!==void 0?e.pixelTolerance:10,this.rBush_=new ee,this.GEOMETRY_SEGMENTERS_={Point:this.segmentPointGeometry_.bind(this),LineString:this.segmentLineStringGeometry_.bind(this),LinearRing:this.segmentLineStringGeometry_.bind(this),Polygon:this.segmentPolygonGeometry_.bind(this),MultiPoint:this.segmentMultiPointGeometry_.bind(this),MultiLineString:this.segmentMultiLineStringGeometry_.bind(this),MultiPolygon:this.segmentMultiPolygonGeometry_.bind(this),GeometryCollection:this.segmentGeometryCollectionGeometry_.bind(this),Circle:this.segmentCircleGeometry_.bind(this)}}addFeature(e,t){t=t!==void 0?t:!0;const n=E(e),i=e.getGeometry();if(i){const s=this.GEOMETRY_SEGMENTERS_[i.getType()];if(s){this.indexedFeaturesExtents_[n]=i.getExtent(ce());const r=[];if(s(r,i),r.length===1)this.rBush_.insert(x(r[0]),{feature:e,segment:r[0]});else if(r.length>1){const a=r.map(h=>x(h)),o=r.map(h=>({feature:e,segment:h}));this.rBush_.load(a,o)}}}t&&(this.featureChangeListenerKeys_[n]=M(e,j.CHANGE,this.handleFeatureChange_,this))}getFeatures_(){let e;return this.features_?e=this.features_:this.source_&&(e=this.source_.getFeatures()),e}handleEvent(e){const t=this.snapTo(e.pixel,e.coordinate,e.map);return t&&(e.coordinate=t.vertex.slice(0,2),e.pixel=t.vertexPixel,this.dispatchEvent(new Se(Ee.SNAP,{vertex:e.coordinate,vertexPixel:e.pixel,feature:t.feature}))),super.handleEvent(e)}handleFeatureAdd_(e){const t=$(e);t&&this.addFeature(t)}handleFeatureRemove_(e){const t=$(e);t&&this.removeFeature(t)}handleFeatureChange_(e){const t=e.target;if(this.handlingDownUpSequence){const n=E(t);n in this.pendingFeatures_||(this.pendingFeatures_[n]=t)}else this.updateFeature_(t)}handleUpEvent(e){const t=Object.values(this.pendingFeatures_);return t.length&&(t.forEach(this.updateFeature_.bind(this)),this.pendingFeatures_={}),!1}removeFeature(e,t){const n=t!==void 0?t:!0,i=E(e),s=this.indexedFeaturesExtents_[i];if(s){const r=this.rBush_,a=[];r.forEachInExtent(s,function(o){e===o.feature&&a.push(o)});for(let o=a.length-1;o>=0;--o)r.remove(a[o])}n&&(B(this.featureChangeListenerKeys_[i]),delete this.featureChangeListenerKeys_[i])}setMap(e){const t=this.getMap(),n=this.featuresListenerKeys_,i=this.getFeatures_();t&&(n.forEach(B),n.length=0,this.rBush_.clear(),Object.values(this.featureChangeListenerKeys_).forEach(B),this.featureChangeListenerKeys_={}),super.setMap(e),e&&(this.features_?n.push(M(this.features_,D.ADD,this.handleFeatureAdd_,this),M(this.features_,D.REMOVE,this.handleFeatureRemove_,this)):this.source_&&n.push(M(this.source_,R.ADDFEATURE,this.handleFeatureAdd_,this),M(this.source_,R.REMOVEFEATURE,this.handleFeatureRemove_,this)),i.forEach(s=>this.addFeature(s)))}snapTo(e,t,n){n.getView().getProjection();const i=m(t),s=J(Q(x([i]),n.getView().getResolution()*this.pixelTolerance_)),r=this.rBush_.getInExtent(s),a=r.length;if(a===0)return null;let o,h=1/0,u;const c=this.pixelTolerance_*this.pixelTolerance_,d=()=>{if(o){const l=n.getPixelFromCoordinate(o);if(F(e,l)<=c)return{vertex:o,vertexPixel:[Math.round(l[0]),Math.round(l[1])],feature:u}}return null};if(this.vertex_){for(let g=0;g<a;++g){const f=r[g];f.feature.getGeometry().getType()!=="Circle"&&f.segment.forEach(y=>{const p=m(y),S=F(i,p);S<h&&(o=y,h=S,u=f.feature)})}const l=d();if(l)return l}if(this.edge_){for(let g=0;g<a;++g){let f=null;const y=r[g];if(y.feature.getGeometry().getType()==="Circle"){let p=y.feature.getGeometry();f=ge(i,p)}else{const[p,S]=y.segment;S&&(I[0]=m(p),I[1]=m(S),f=Z(i,I))}if(f){const p=F(i,f);p<h&&(o=b(f),h=p)}}const l=d();if(l)return l}return null}updateFeature_(e){this.removeFeature(e,!1),this.addFeature(e,!1)}segmentCircleGeometry_(e,t){this.getMap().getView().getProjection();const s=de(t).getCoordinates()[0];for(let r=0,a=s.length-1;r<a;++r)e.push(s.slice(r,r+2))}segmentGeometryCollectionGeometry_(e,t){const n=t.getGeometriesArray();for(let i=0;i<n.length;++i){const s=this.GEOMETRY_SEGMENTERS_[n[i].getType()];s&&s(e,n[i])}}segmentLineStringGeometry_(e,t){const n=t.getCoordinates();for(let i=0,s=n.length-1;i<s;++i)e.push(n.slice(i,i+2))}segmentMultiLineStringGeometry_(e,t){const n=t.getCoordinates();for(let i=0,s=n.length;i<s;++i){const r=n[i];for(let a=0,o=r.length-1;a<o;++a)e.push(r.slice(a,a+2))}}segmentMultiPointGeometry_(e,t){t.getCoordinates().forEach(n=>{e.push([n])})}segmentMultiPolygonGeometry_(e,t){const n=t.getCoordinates();for(let i=0,s=n.length;i<s;++i){const r=n[i];for(let a=0,o=r.length;a<o;++a){const h=r[a];for(let u=0,c=h.length-1;u<c;++u)e.push(h.slice(u,u+2))}}}segmentPointGeometry_(e,t){e.push([t.getCoordinates()])}segmentPolygonGeometry_(e,t){const n=t.getCoordinates();for(let i=0,s=n.length;i<s;++i){const r=n[i];for(let a=0,o=r.length-1;a<o;++a)e.push(r.slice(a,a+2))}}}const Ge=Ce;export{Te as M,Ge as S};
