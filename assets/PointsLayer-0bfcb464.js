import{Y as R,aI as f,a6 as C,K as _,a3 as p,aO as b,a9 as v,aW as F,aP as B,_ as y,as as L,aV as D,aS as w,L as x}from"./Layer-3b715193.js";import{a as g}from"./Vector-a4e726e1.js";import{i as P,m as W,e as T,f as G,h as E,E as N,d as l,c as U,l as S}from"./ShaderBuilder-d8651322.js";import{c as z,W as A,a as M,g as O}from"./worldUtil-7fa77630.js";class j extends P{constructor(e,t){const o=t.uniforms||{},i=f();o[W.PROJECTION_MATRIX]=i,super(e,{uniforms:o,postProcesses:t.postProcesses}),this.sourceRevision_=-1,this.verticesBuffer_=new T(G,E),this.indicesBuffer_=new T(N,E),this.vertexShader_=t.vertexShader,this.fragmentShader_=t.fragmentShader,this.program_,this.hitDetectionEnabled_=t.hitDetectionEnabled??!0;const h=t.attributes?t.attributes.map(function(r){return{name:"a_prop_"+r.name,size:1,type:l.FLOAT}}):[];this.attributes=[{name:"a_position",size:2,type:l.FLOAT},{name:"a_index",size:1,type:l.FLOAT}],this.hitDetectionEnabled_&&(this.attributes.push({name:"a_prop_hitColor",size:4,type:l.FLOAT}),this.attributes.push({name:"a_featureUid",size:1,type:l.FLOAT})),this.attributes.push(...h),this.customAttributes=t.attributes?t.attributes:[],this.previousExtent_=R(),this.currentTransform_=i,this.renderTransform_=f(),this.invertRenderTransform_=f(),this.renderInstructions_=new Float32Array(0),this.hitRenderTarget_,this.lastSentId=0,this.worker_=z(),this.worker_.addEventListener("message",r=>{const n=r.data;if(n.type===A.GENERATE_POINT_BUFFERS){const c=n.projectionTransform;this.verticesBuffer_.fromArrayBuffer(n.vertexBuffer),this.helper.flushBufferData(this.verticesBuffer_),this.indicesBuffer_.fromArrayBuffer(n.indexBuffer),this.helper.flushBufferData(this.indicesBuffer_),this.renderTransform_=c,C(this.invertRenderTransform_,this.renderTransform_),this.renderInstructions_=new Float32Array(r.data.renderInstructions),n.id===this.lastSentId&&(this.ready=!0),this.getLayer().changed()}}),this.featureCache_={},this.featureCount_=0;const s=this.getLayer().getSource();this.sourceListenKeys_=[_(s,g.ADDFEATURE,this.handleSourceFeatureAdded_,this),_(s,g.CHANGEFEATURE,this.handleSourceFeatureChanged_,this),_(s,g.REMOVEFEATURE,this.handleSourceFeatureDelete_,this),_(s,g.CLEAR,this.handleSourceFeatureClear_,this)],s.forEachFeature(r=>{this.featureCache_[p(r)]={feature:r,properties:r.getProperties(),geometry:r.getGeometry()},this.featureCount_++})}afterHelperCreated(){this.program_=this.helper.getProgram(this.fragmentShader_,this.vertexShader_),this.hitDetectionEnabled_&&(this.hitRenderTarget_=new M(this.helper))}handleSourceFeatureAdded_(e){const t=e.feature;this.featureCache_[p(t)]={feature:t,properties:t.getProperties(),geometry:t.getGeometry()},this.featureCount_++}handleSourceFeatureChanged_(e){const t=e.feature;this.featureCache_[p(t)]={feature:t,properties:t.getProperties(),geometry:t.getGeometry()}}handleSourceFeatureDelete_(e){const t=e.feature;delete this.featureCache_[p(t)],this.featureCount_--}handleSourceFeatureClear_(){this.featureCache_={},this.featureCount_=0}renderFrame(e){const t=this.helper.getGL();this.preRender(t,e);const[o,i,h]=O(e,this.getLayer());return this.renderWorlds(e,!1,o,i,h),this.helper.finalizeDraw(e,this.dispatchPreComposeEvent,this.dispatchPostComposeEvent),this.hitDetectionEnabled_&&(this.renderWorlds(e,!0,o,i,h),this.hitRenderTarget_.clearCachedData()),this.postRender(t,e),this.helper.getCanvas()}prepareFrameInternal(e){const t=this.getLayer(),o=t.getSource(),i=e.viewState,h=!e.viewHints[b.ANIMATING]&&!e.viewHints[b.INTERACTING],s=!v(this.previousExtent_,e.extent),r=this.sourceRevision_<o.getRevision();if(r&&(this.sourceRevision_=o.getRevision()),h&&(s||r)){const n=i.projection,c=i.resolution,a=t instanceof F?t.getRenderBuffer():0,d=B(e.extent,a*c);o.loadFeatures(d,c,n),this.rebuildBuffers_(e),this.previousExtent_=e.extent.slice()}return this.helper.useProgram(this.program_,e),this.helper.prepareDraw(e),this.helper.bindBuffer(this.verticesBuffer_),this.helper.bindBuffer(this.indicesBuffer_),this.helper.enableAttributes(this.attributes),!0}rebuildBuffers_(e){const t=f();this.helper.makeProjectionTransform(e,t);const i=(this.hitDetectionEnabled_?7:2)+this.customAttributes.length,h=i*this.featureCount_;(!this.renderInstructions_||this.renderInstructions_.length!==h)&&(this.renderInstructions_=new Float32Array(h));let s,r;const n=[],c=[];let a=-1;for(const m in this.featureCache_)if(s=this.featureCache_[m],r=s.geometry,!(!r||r.getType()!=="Point")){if(n[0]=r.getFlatCoordinates()[0],n[1]=r.getFlatCoordinates()[1],y(t,n),this.renderInstructions_[++a]=n[0],this.renderInstructions_[++a]=n[1],this.hitDetectionEnabled_){const u=U(a+5,c);this.renderInstructions_[++a]=u[0],this.renderInstructions_[++a]=u[1],this.renderInstructions_[++a]=u[2],this.renderInstructions_[++a]=u[3],this.renderInstructions_[++a]=Number(m)}for(let u=0;u<this.customAttributes.length;u++){const I=this.customAttributes[u].callback(s.feature,s.properties);this.renderInstructions_[++a]=I}}const d={id:++this.lastSentId,type:A.GENERATE_POINT_BUFFERS,renderInstructions:this.renderInstructions_.buffer,customAttributesSize:i-2};d.projectionTransform=t,this.ready=!1,this.worker_.postMessage(d,[this.renderInstructions_.buffer]),this.renderInstructions_=null}forEachFeatureAtCoordinate(e,t,o,i,h){if(L(this.hitDetectionEnabled_,"`forEachFeatureAtCoordinate` cannot be used on a WebGL layer if the hit detection logic has been disabled using the `disableHitDetection: true` option."),!this.renderInstructions_||!this.hitDetectionEnabled_)return;const s=y(t.coordinateToPixelTransform,e.slice()),r=this.hitRenderTarget_.readPixel(s[0]/2,s[1]/2),n=[r[0]/255,r[1]/255,r[2]/255,r[3]/255],c=S(n),a=this.renderInstructions_[c],d=Math.floor(a).toString(),u=this.getLayer().getSource().getFeatureByUid(d);if(u)return i(u,this.getLayer(),null)}renderWorlds(e,t,o,i,h){let s=o;this.helper.useProgram(this.program_,e),t&&(this.hitRenderTarget_.setSize([Math.floor(e.size[0]/2),Math.floor(e.size[1]/2)]),this.helper.prepareDrawToRenderTarget(e,this.hitRenderTarget_,!0)),this.helper.bindBuffer(this.verticesBuffer_),this.helper.bindBuffer(this.indicesBuffer_),this.helper.enableAttributes(this.attributes);do{this.helper.makeProjectionTransform(e,this.currentTransform_),D(this.currentTransform_,s*h,0),w(this.currentTransform_,this.invertRenderTransform_),this.helper.applyUniforms(e),this.helper.applyHitDetectionUniform(t);const r=this.indicesBuffer_.getSize();this.helper.drawElements(0,r)}while(++s<i)}disposeInternal(){this.worker_.terminate(),this.layer_=null,this.sourceListenKeys_.forEach(function(e){x(e)}),this.sourceListenKeys_=null,super.disposeInternal()}renderDeclutter(){}}const $=j;export{$ as W};
