import{N as Y,cI as K,cJ as X,cd as $,cK as J,bT as I,bV as L,E as V,e as y,aF as T,P as A,cH as P,cL as k,cM as m,Y as x,cN as p,t as D,W as Q,r as z,aN as Z,cO as b,aB as ee,cP as te,ay as ie,cQ as ne}from"./Layer-3211d6ef.js";import{R as se,V as re,a as N,F as j}from"./Vector-163f0152.js";import{V as oe}from"./Vector-2de0a908.js";import{d as ae}from"./Style-22e788f3.js";const O=0,E=1,U=[0,0,0,0],S=[],w={MODIFYSTART:"modifystart",MODIFYEND:"modifyend"};class G extends ie{constructor(e,t,n){super(e),this.features=t,this.mapBrowserEvent=n}}class he extends Y{constructor(e){super(e),this.on,this.once,this.un,this.boundHandleFeatureChange_=this.handleFeatureChange_.bind(this),this.condition_=e.condition?e.condition:K,this.defaultDeleteCondition_=function(n){return X(n)&&$(n)},this.deleteCondition_=e.deleteCondition?e.deleteCondition:this.defaultDeleteCondition_,this.insertVertexCondition_=e.insertVertexCondition?e.insertVertexCondition:J,this.vertexFeature_=null,this.vertexSegments_=null,this.lastPixel_=[0,0],this.ignoreNextSingleClick_=!1,this.featuresBeingModified_=null,this.rBush_=new se,this.pixelTolerance_=e.pixelTolerance!==void 0?e.pixelTolerance:10,this.snappedToVertex_=!1,this.changingFeature_=!1,this.dragSegments_=[],this.overlay_=new oe({source:new re({useSpatialIndex:!1,wrapX:!!e.wrapX}),style:e.style?e.style:ge(),updateWhileAnimating:!0,updateWhileInteracting:!0}),this.SEGMENT_WRITERS_={Point:this.writePointGeometry_.bind(this),LineString:this.writeLineStringGeometry_.bind(this),LinearRing:this.writeLineStringGeometry_.bind(this),Polygon:this.writePolygonGeometry_.bind(this),MultiPoint:this.writeMultiPointGeometry_.bind(this),MultiLineString:this.writeMultiLineStringGeometry_.bind(this),MultiPolygon:this.writeMultiPolygonGeometry_.bind(this),Circle:this.writeCircleGeometry_.bind(this),GeometryCollection:this.writeGeometryCollectionGeometry_.bind(this)},this.source_=null,this.hitDetection_=null;let t;if(e.features?t=e.features:e.source&&(this.source_=e.source,t=new I(this.source_.getFeatures()),this.source_.addEventListener(N.ADDFEATURE,this.handleSourceAdd_.bind(this)),this.source_.addEventListener(N.REMOVEFEATURE,this.handleSourceRemove_.bind(this))),!t)throw new Error("The modify interaction requires features, a source or a layer");e.hitDetection&&(this.hitDetection_=e.hitDetection),this.features_=t,this.features_.forEach(this.addFeature_.bind(this)),this.features_.addEventListener(L.ADD,this.handleFeatureAdd_.bind(this)),this.features_.addEventListener(L.REMOVE,this.handleFeatureRemove_.bind(this)),this.lastPointerEvent_=null,this.delta_=[0,0],this.snapToPointer_=e.snapToPointer===void 0?!this.hitDetection_:e.snapToPointer}addFeature_(e){const t=e.getGeometry();if(t){const i=this.SEGMENT_WRITERS_[t.getType()];i&&i(e,t)}const n=this.getMap();n&&n.isRendered()&&this.getActive()&&this.handlePointerAtPixel_(this.lastPixel_,n),e.addEventListener(V.CHANGE,this.boundHandleFeatureChange_)}willModifyFeatures_(e,t){if(!this.featuresBeingModified_){this.featuresBeingModified_=new I;const n=this.featuresBeingModified_.getArray();for(let i=0,s=t.length;i<s;++i){const o=t[i];for(let h=0,r=o.length;h<r;++h){const a=o[h].feature;a&&!n.includes(a)&&this.featuresBeingModified_.push(a)}}this.featuresBeingModified_.getLength()===0?this.featuresBeingModified_=null:this.dispatchEvent(new G(w.MODIFYSTART,this.featuresBeingModified_,e))}}removeFeature_(e){this.removeFeatureSegmentData_(e),this.vertexFeature_&&this.features_.getLength()===0&&(this.overlay_.getSource().removeFeature(this.vertexFeature_),this.vertexFeature_=null),e.removeEventListener(V.CHANGE,this.boundHandleFeatureChange_)}removeFeatureSegmentData_(e){const t=this.rBush_,n=[];t.forEach(function(i){e===i.feature&&n.push(i)});for(let i=n.length-1;i>=0;--i){const s=n[i];for(let o=this.dragSegments_.length-1;o>=0;--o)this.dragSegments_[o][0]===s&&this.dragSegments_.splice(o,1);t.remove(s)}}setActive(e){this.vertexFeature_&&!e&&(this.overlay_.getSource().removeFeature(this.vertexFeature_),this.vertexFeature_=null),super.setActive(e)}setMap(e){this.overlay_.setMap(e),super.setMap(e)}getOverlay(){return this.overlay_}handleSourceAdd_(e){e.feature&&this.features_.push(e.feature)}handleSourceRemove_(e){e.feature&&this.features_.remove(e.feature)}handleFeatureAdd_(e){this.addFeature_(e.element)}handleFeatureChange_(e){if(!this.changingFeature_){const t=e.target;this.removeFeature_(t),this.addFeature_(t)}}handleFeatureRemove_(e){this.removeFeature_(e.element)}writePointGeometry_(e,t){const n=t.getCoordinates(),i={feature:e,geometry:t,segment:[n,n]};this.rBush_.insert(t.getExtent(),i)}writeMultiPointGeometry_(e,t){const n=t.getCoordinates();for(let i=0,s=n.length;i<s;++i){const o=n[i],h={feature:e,geometry:t,depth:[i],index:i,segment:[o,o]};this.rBush_.insert(t.getExtent(),h)}}writeLineStringGeometry_(e,t){const n=t.getCoordinates();for(let i=0,s=n.length-1;i<s;++i){const o=n.slice(i,i+2),h={feature:e,geometry:t,index:i,segment:o};this.rBush_.insert(y(o),h)}}writeMultiLineStringGeometry_(e,t){const n=t.getCoordinates();for(let i=0,s=n.length;i<s;++i){const o=n[i];for(let h=0,r=o.length-1;h<r;++h){const a=o.slice(h,h+2),g={feature:e,geometry:t,depth:[i],index:h,segment:a};this.rBush_.insert(y(a),g)}}}writePolygonGeometry_(e,t){const n=t.getCoordinates();for(let i=0,s=n.length;i<s;++i){const o=n[i];for(let h=0,r=o.length-1;h<r;++h){const a=o.slice(h,h+2),g={feature:e,geometry:t,depth:[i],index:h,segment:a};this.rBush_.insert(y(a),g)}}}writeMultiPolygonGeometry_(e,t){const n=t.getCoordinates();for(let i=0,s=n.length;i<s;++i){const o=n[i];for(let h=0,r=o.length;h<r;++h){const a=o[h];for(let g=0,l=a.length-1;g<l;++g){const c=a.slice(g,g+2),d={feature:e,geometry:t,depth:[h,i],index:g,segment:c};this.rBush_.insert(y(c),d)}}}}writeCircleGeometry_(e,t){const n=t.getCenter(),i={feature:e,geometry:t,index:O,segment:[n,n]},s={feature:e,geometry:t,index:E,segment:[n,n]},o=[i,s];i.featureSegments=o,s.featureSegments=o,this.rBush_.insert(T(n),i);let h=t;this.rBush_.insert(h.getExtent(),s)}writeGeometryCollectionGeometry_(e,t){const n=t.getGeometriesArray();for(let i=0;i<n.length;++i){const s=n[i],o=this.SEGMENT_WRITERS_[s.getType()];o(e,s)}}createOrUpdateVertexFeature_(e,t,n){let i=this.vertexFeature_;return i?i.getGeometry().setCoordinates(e):(i=new j(new A(e)),this.vertexFeature_=i,this.overlay_.getSource().addFeature(i)),i.set("features",t),i.set("geometries",n),i}handleEvent(e){if(!e.originalEvent)return!0;this.lastPointerEvent_=e;let t;return!e.map.getView().getInteracting()&&e.type==P.POINTERMOVE&&!this.handlingDownUpSequence&&this.handlePointerMove_(e),this.vertexFeature_&&this.deleteCondition_(e)&&(e.type!=P.SINGLECLICK||!this.ignoreNextSingleClick_?t=this.removePoint():t=!0),e.type==P.SINGLECLICK&&(this.ignoreNextSingleClick_=!1),super.handleEvent(e)&&!t}handleDragEvent(e){this.ignoreNextSingleClick_=!1,this.willModifyFeatures_(e,this.dragSegments_);const t=[e.coordinate[0]+this.delta_[0],e.coordinate[1]+this.delta_[1]],n=[],i=[];for(let s=0,o=this.dragSegments_.length;s<o;++s){const h=this.dragSegments_[s],r=h[0],a=r.feature;n.includes(a)||n.push(a);const g=r.geometry;i.includes(g)||i.push(g);const l=r.depth;let c;const d=r.segment,u=h[1];for(;t.length<g.getStride();)t.push(d[u][t.length]);switch(g.getType()){case"Point":c=t,d[0]=t,d[1]=t;break;case"MultiPoint":c=g.getCoordinates(),c[r.index]=t,d[0]=t,d[1]=t;break;case"LineString":c=g.getCoordinates(),c[r.index+u]=t,d[u]=t;break;case"MultiLineString":c=g.getCoordinates(),c[l[0]][r.index+u]=t,d[u]=t;break;case"Polygon":c=g.getCoordinates(),c[l[0]][r.index+u]=t,d[u]=t;break;case"MultiPolygon":c=g.getCoordinates(),c[l[1]][l[0]][r.index+u]=t,d[u]=t;break;case"Circle":if(d[0]=t,d[1]=t,r.index===O)this.changingFeature_=!0,g.setCenter(t),this.changingFeature_=!1;else{this.changingFeature_=!0,e.map.getView().getProjection();let f=k(m(g.getCenter()),m(t));g.setRadius(f),this.changingFeature_=!1}break}c&&this.setGeometryCoordinates_(g,c)}this.createOrUpdateVertexFeature_(t,n,i)}handleDownEvent(e){if(!this.condition_(e))return!1;const t=e.coordinate;this.handlePointerAtPixel_(e.pixel,e.map,t),this.dragSegments_.length=0,this.featuresBeingModified_=null;const n=this.vertexFeature_;if(n){e.map.getView().getProjection();const i=[],s=n.getGeometry().getCoordinates(),o=y([s]),h=this.rBush_.getInExtent(o),r={};h.sort(de);for(let a=0,g=h.length;a<g;++a){const l=h[a],c=l.segment;let d=x(l.geometry);const u=l.depth;if(u&&(d+="-"+u.join("-")),r[d]||(r[d]=new Array(2)),l.geometry.getType()==="Circle"&&l.index===E){const f=H(t,l);p(f,s)&&!r[d][0]&&(this.dragSegments_.push([l,0]),r[d][0]=l);continue}if(p(c[0],s)&&!r[d][0]){this.dragSegments_.push([l,0]),r[d][0]=l;continue}if(p(c[1],s)&&!r[d][1]){if(r[d][0]&&r[d][0].index===0){let f=l.geometry.getCoordinates();switch(l.geometry.getType()){case"LineString":case"MultiLineString":continue;case"MultiPolygon":f=f[u[1]];case"Polygon":if(l.index!==f[u[0]].length-2)continue;break}}this.dragSegments_.push([l,1]),r[d][1]=l;continue}x(c)in this.vertexSegments_&&!r[d][0]&&!r[d][1]&&this.insertVertexCondition_(e)&&i.push(l)}i.length&&this.willModifyFeatures_(e,[i]);for(let a=i.length-1;a>=0;--a)this.insertVertex_(i[a],s)}return!!this.vertexFeature_}handleUpEvent(e){for(let t=this.dragSegments_.length-1;t>=0;--t){const n=this.dragSegments_[t][0],i=n.geometry;if(i.getType()==="Circle"){const s=i.getCenter(),o=n.featureSegments[0],h=n.featureSegments[1];o.segment[0]=s,o.segment[1]=s,h.segment[0]=s,h.segment[1]=s,this.rBush_.update(T(s),o);let r=i;this.rBush_.update(r.getExtent(),h)}else this.rBush_.update(y(n.segment),n)}return this.featuresBeingModified_&&(this.dispatchEvent(new G(w.MODIFYEND,this.featuresBeingModified_,e)),this.featuresBeingModified_=null),!1}handlePointerMove_(e){this.lastPixel_=e.pixel,this.handlePointerAtPixel_(e.pixel,e.map,e.coordinate)}handlePointerAtPixel_(e,t,n){const i=n||t.getCoordinateFromPixel(e);t.getView().getProjection();const s=function(r,a){return q(i,r)-q(i,a)};let o,h;if(this.hitDetection_){const r=typeof this.hitDetection_=="object"?a=>a===this.hitDetection_:void 0;t.forEachFeatureAtPixel(e,(a,g,l)=>{l&&(l=new A(D(l.getCoordinates())));const c=l||a.getGeometry();if(c.getType()==="Point"&&a instanceof j&&this.features_.getArray().includes(a)){h=c;const d=a.getGeometry().getFlatCoordinates().slice(0,2);o=[{feature:a,geometry:h,segment:[d,d]}]}return!0},{layerFilter:r})}if(!o){const r=Q(T(i,U)),a=t.getView().getResolution()*this.pixelTolerance_,g=z(Z(r,a,U));o=this.rBush_.getInExtent(g)}if(o&&o.length>0){const r=o.sort(s)[0],a=r.segment;let g=H(i,r);const l=t.getPixelFromCoordinate(g);let c=k(e,l);if(h||c<=this.pixelTolerance_){const d={};if(d[x(a)]=!0,this.snapToPointer_||(this.delta_[0]=g[0]-i[0],this.delta_[1]=g[1]-i[1]),r.geometry.getType()==="Circle"&&r.index===E)this.snappedToVertex_=!0,this.createOrUpdateVertexFeature_(g,[r.feature],[r.geometry]);else{const u=t.getPixelFromCoordinate(a[0]),f=t.getPixelFromCoordinate(a[1]),C=b(l,u),B=b(l,f);c=Math.sqrt(Math.min(C,B)),this.snappedToVertex_=c<=this.pixelTolerance_,this.snappedToVertex_&&(g=C>B?a[1]:a[0]),this.createOrUpdateVertexFeature_(g,[r.feature],[r.geometry]);const M={};M[x(r.geometry)]=!0;for(let v=1,W=o.length;v<W;++v){const F=o[v].segment;if(p(a[0],F[0])&&p(a[1],F[1])||p(a[0],F[1])&&p(a[1],F[0])){const R=x(o[v].geometry);R in M||(M[R]=!0,d[x(F)]=!0)}else break}}this.vertexSegments_=d;return}}this.vertexFeature_&&(this.overlay_.getSource().removeFeature(this.vertexFeature_),this.vertexFeature_=null)}insertVertex_(e,t){const n=e.segment,i=e.feature,s=e.geometry,o=e.depth,h=e.index;let r;for(;t.length<s.getStride();)t.push(0);switch(s.getType()){case"MultiLineString":r=s.getCoordinates(),r[o[0]].splice(h+1,0,t);break;case"Polygon":r=s.getCoordinates(),r[o[0]].splice(h+1,0,t);break;case"MultiPolygon":r=s.getCoordinates(),r[o[1]][o[0]].splice(h+1,0,t);break;case"LineString":r=s.getCoordinates(),r.splice(h+1,0,t);break;default:return}this.setGeometryCoordinates_(s,r);const a=this.rBush_;a.remove(e),this.updateSegmentIndices_(s,h,o,1);const g={segment:[n[0],t],feature:i,geometry:s,depth:o,index:h};a.insert(y(g.segment),g),this.dragSegments_.push([g,1]);const l={segment:[t,n[1]],feature:i,geometry:s,depth:o,index:h+1};a.insert(y(l.segment),l),this.dragSegments_.push([l,0]),this.ignoreNextSingleClick_=!0}removePoint(){if(this.lastPointerEvent_&&this.lastPointerEvent_.type!=P.POINTERDRAG){const e=this.lastPointerEvent_;this.willModifyFeatures_(e,this.dragSegments_);const t=this.removeVertex_();return this.featuresBeingModified_&&this.dispatchEvent(new G(w.MODIFYEND,this.featuresBeingModified_,e)),this.featuresBeingModified_=null,t}return!1}removeVertex_(){const e=this.dragSegments_,t={};let n=!1,i,s,o,h,r,a,g,l,c,d,u;for(r=e.length-1;r>=0;--r)o=e[r],d=o[0],u=x(d.feature),d.depth&&(u+="-"+d.depth.join("-")),u in t||(t[u]={}),o[1]===0?(t[u].right=d,t[u].index=d.index):o[1]==1&&(t[u].left=d,t[u].index=d.index+1);for(u in t){switch(c=t[u].right,g=t[u].left,a=t[u].index,l=a-1,g!==void 0?d=g:d=c,l<0&&(l=0),h=d.geometry,s=h.getCoordinates(),i=s,n=!1,h.getType()){case"MultiLineString":s[d.depth[0]].length>2&&(s[d.depth[0]].splice(a,1),n=!0);break;case"LineString":s.length>2&&(s.splice(a,1),n=!0);break;case"MultiPolygon":i=i[d.depth[1]];case"Polygon":i=i[d.depth[0]],i.length>4&&(a==i.length-1&&(a=0),i.splice(a,1),n=!0,a===0&&(i.pop(),i.push(i[0]),l=i.length-1));break}if(n){this.setGeometryCoordinates_(h,s);const f=[];if(g!==void 0&&(this.rBush_.remove(g),f.push(g.segment[0])),c!==void 0&&(this.rBush_.remove(c),f.push(c.segment[1])),g!==void 0&&c!==void 0){const C={depth:d.depth,feature:d.feature,geometry:d.geometry,index:l,segment:f};this.rBush_.insert(y(C.segment),C)}this.updateSegmentIndices_(h,a,d.depth,-1),this.vertexFeature_&&(this.overlay_.getSource().removeFeature(this.vertexFeature_),this.vertexFeature_=null),e.length=0}}return n}setGeometryCoordinates_(e,t){this.changingFeature_=!0,e.setCoordinates(t),this.changingFeature_=!1}updateSegmentIndices_(e,t,n,i){this.rBush_.forEachInExtent(e.getExtent(),function(s){s.geometry===e&&(n===void 0||s.depth===void 0||ee(s.depth,n))&&s.index>t&&(s.index+=i)})}}function de(_,e){return _.index-e.index}function q(_,e,t){const n=e.geometry;if(n.getType()==="Circle"){let s=n;if(e.index===E){const o=b(s.getCenter(),m(_)),h=Math.sqrt(o)-s.getRadius();return h*h}}const i=m(_);return S[0]=m(e.segment[0]),S[1]=m(e.segment[1]),ne(i,S)}function H(_,e,t){const n=e.geometry;if(n.getType()==="Circle"&&e.index===E)return D(n.getClosestPoint(m(_)));const i=m(_);return S[0]=m(e.segment[0]),S[1]=m(e.segment[1]),D(te(i,S))}function ge(){const _=ae();return function(e,t){return _.Point}}const _e=he;export{_e as M};
