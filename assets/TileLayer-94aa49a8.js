import{C as me}from"./Layer-10451559.js";import{d as we,I as Ce,R as ce}from"./TileProperty-167ee2c2.js";import{W as ve,X as D,Y as de,Z as Ee,Q as Ie,k as Pe,_ as Le,$ as he,z as je,a0 as ge,a1 as S,a2 as ue,a3 as ze,a4 as De,a5 as Fe,a6 as Ae,j as be,a7 as Me}from"./Layer-227d2e40.js";class Oe extends me{constructor(e){super(e),this.extentChanged=!0,this.renderedExtent_=null,this.renderedPixelRatio,this.renderedProjection=null,this.renderedRevision,this.renderedTiles=[],this.newTiles_=!1,this.tmpExtent=ve(),this.tmpTileRange_=new we(0,0,0,0)}isDrawableTile(e){const i=this.getLayer(),t=e.getState(),o=i.getUseInterimTilesOnError();return t==D.LOADED||t==D.EMPTY||t==D.ERROR&&!o}getTile(e,i,t,o){const d=o.pixelRatio,p=o.viewState.projection,s=this.getLayer();let n=s.getSource().getTile(e,i,t,d,p);return n.getState()==D.ERROR&&s.getUseInterimTilesOnError()&&s.getPreload()>0&&(this.newTiles_=!0),this.isDrawableTile(n)||(n=n.getInterimTile()),n}getData(e){const i=this.frameState;if(!i)return null;const t=this.getLayer(),o=de(i.pixelToCoordinateTransform,e.slice()),d=t.getExtent();if(d&&!Ee(d,o))return null;const p=i.pixelRatio,s=i.viewState.projection,x=i.viewState,n=t.getRenderSource(),h=n.getTileGridForProjection(x.projection),r=n.getTilePixelRatio(i.pixelRatio);for(let u=h.getZForResolution(x.resolution);u>=h.getMinZoom();--u){const c=h.getTileCoordForCoordAndZ(o,u),l=n.getTile(u,c[1],c[2],p,s);if(!(l instanceof Ce||l instanceof ce)||l instanceof ce&&l.getState()===D.EMPTY)return null;if(l.getState()!==D.LOADED)continue;const m=h.getOrigin(u),w=Ie(h.getTileSize(u)),R=h.getResolution(u),T=Math.floor(r*((o[0]-m[0])/R-c[1]*w[0])),C=Math.floor(r*((m[1]-o[1])/R-c[2]*w[1])),g=Math.round(r*n.getGutterForProjection(x.projection));return this.getImageData(l.getImage(),T+g,C+g)}return null}loadedTileCallback(e,i,t){return this.isDrawableTile(t)?super.loadedTileCallback(e,i,t):!1}prepareFrame(e){return!!this.getLayer().getSource()}renderFrame(e,i){const t=e.layerStatesArray[e.layerIndex],o=e.viewState,d=o.projection,p=o.resolution,s=o.center,x=o.rotation,n=e.pixelRatio,h=this.getLayer(),r=h.getSource(),u=r.getRevision(),c=r.getTileGridForProjection(d),l=c.getZForResolution(p,r.zDirection),m=c.getResolution(l);let w=e.extent;const R=e.viewState.resolution,T=r.getTilePixelRatio(n),C=Math.round(Pe(w)/R*n),g=Math.round(Le(w)/R*n),I=t.extent&&he(t.extent);I&&(w=je(w,he(t.extent)));const v=m*C/2/T,N=m*g/2/T,Z=[s[0]-v,s[1]-N,s[0]+v,s[1]+N],k=c.getTileRangeForExtentAndZ(w,l),_={};_[l]={};const J=this.createLoadedTileFinder(r,d,_),ee=this.tmpExtent,te=this.tmpTileRange_;this.newTiles_=!1;const Te=x?ge(o.center,R,x,e.size):void 0;for(let z=k.minX;z<=k.maxX;++z)for(let f=k.minY;f<=k.maxY;++f){if(x&&!c.tileCoordIntersectsViewport([l,z,f],Te))continue;const y=this.getTile(l,z,f,e);if(this.isDrawableTile(y)){const b=S(this);if(y.getState()==D.LOADED){_[l][y.tileCoord.toString()]=y;let M=y.inTransition(b);M&&t.opacity!==1&&(y.endTransition(b),M=!1),!this.newTiles_&&(M||!this.renderedTiles.includes(y))&&(this.newTiles_=!0)}if(y.getAlpha(b,e.time)===1)continue}const W=c.getTileCoordChildTileRange(y.tileCoord,te,ee);let Y=!1;W&&(Y=J(l+1,W)),Y||c.forEachTileCoordParentTileRange(y.tileCoord,J,te,ee)}const Q=m/p*n/T;ue(this.pixelTransform,e.size[0]/2,e.size[1]/2,1/n,1/n,x,-C/2,-g/2);const V=ze(this.pixelTransform);this.useContainer(i,V,this.getBackground(e));const a=this.context,F=a.canvas;De(this.inversePixelTransform,this.pixelTransform),ue(this.tempTransform,C/2,g/2,Q,Q,0,-C/2,-g/2),F.width!=C||F.height!=g?(F.width=C,F.height=g):this.containerReused||a.clearRect(0,0,C,g),I&&this.clipUnrotated(a,e,I),r.getInterpolate()||(a.imageSmoothingEnabled=!1),this.preRender(a,e),this.renderedTiles.length=0;let K=Object.keys(_).map(Number);K.sort(Fe);let A,B,P;t.opacity===1&&(!this.containerReused||r.getOpaque(e.viewState.projection))?K=K.reverse():(A=[],B=[]);for(let z=K.length-1;z>=0;--z){const f=K[z],y=r.getTilePixelSize(f,n,d),Y=c.getResolution(f)/m,b=y[0]*Y*Q,M=y[1]*Y*Q,$=c.getTileCoordForCoordAndZ(Ae(Z),f),ie=c.getTileCoordExtent($),q=de(this.tempTransform,[T*(ie[0]-Z[0])/m,T*(Z[3]-ie[3])/m]),pe=T*r.getGutterForProjection(d),ne=_[f];for(const xe in ne){const O=ne[xe],oe=O.tileCoord,se=$[1]-oe[1],Re=Math.round(q[0]-(se-1)*b),re=$[2]-oe[2],fe=Math.round(q[1]-(re-1)*M),L=Math.round(q[0]-se*b),j=Math.round(q[1]-re*M),U=Re-L,X=fe-j,le=l===f,ae=le&&O.getAlpha(S(this),e.time)!==1;let H=!1;if(!ae)if(A){P=[L,j,L+U,j,L+U,j+X,L,j+X];for(let G=0,ye=A.length;G<ye;++G)if(l!==f&&f<B[G]){const E=A[G];be([L,j,L+U,j+X],[E[0],E[3],E[4],E[7]])&&(H||(a.save(),H=!0),a.beginPath(),a.moveTo(P[0],P[1]),a.lineTo(P[2],P[3]),a.lineTo(P[4],P[5]),a.lineTo(P[6],P[7]),a.moveTo(E[6],E[7]),a.lineTo(E[4],E[5]),a.lineTo(E[2],E[3]),a.lineTo(E[0],E[1]),a.clip())}A.push(P),B.push(f)}else a.clearRect(L,j,U,X);this.drawTileImage(O,e,L,j,U,X,pe,le),A&&!ae?(H&&a.restore(),this.renderedTiles.unshift(O)):this.renderedTiles.push(O),this.updateUsedTiles(e.usedTiles,r,O)}}return this.renderedRevision=u,this.renderedResolution=m,this.extentChanged=!this.renderedExtent_||!Me(this.renderedExtent_,Z),this.renderedExtent_=Z,this.renderedPixelRatio=n,this.renderedProjection=d,this.manageTilePyramid(e,r,c,n,d,w,l,h.getPreload()),this.scheduleExpireCache(e,r),this.postRender(a,e),t.extent&&a.restore(),a.imageSmoothingEnabled=!0,V!==F.style.transform&&(F.style.transform=V),this.container}drawTileImage(e,i,t,o,d,p,s,x){const n=this.getTileImage(e);if(!n)return;const h=S(this),r=i.layerStatesArray[i.layerIndex],u=r.opacity*(x?e.getAlpha(h,i.time):1),c=u!==this.context.globalAlpha;c&&(this.context.save(),this.context.globalAlpha=u),this.context.drawImage(n,s,s,n.width-2*s,n.height-2*s,t,o,d,p),c&&this.context.restore(),u!==r.opacity?i.animate=!0:x&&e.endTransition(h)}getImage(){const e=this.context;return e?e.canvas:null}getTileImage(e){return e.getImage()}scheduleExpireCache(e,i){if(i.canExpireCache()){const t=(function(o,d,p){const s=S(o);s in p.usedTiles&&o.expireCache(p.viewState.projection,p.usedTiles[s])}).bind(null,i);e.postRenderFunctions.push(t)}}updateUsedTiles(e,i,t){const o=S(i);o in e||(e[o]={}),e[o][t.getKey()]=!0}manageTilePyramid(e,i,t,o,d,p,s,x,n){const h=S(i);h in e.wantedTiles||(e.wantedTiles[h]={});const r=e.wantedTiles[h],u=e.tileQueue,c=t.getMinZoom(),l=e.viewState.rotation,m=l?ge(e.viewState.center,e.viewState.resolution,l,e.size):void 0;let w=0,R,T,C,g,I,v;for(v=c;v<=s;++v)for(T=t.getTileRangeForExtentAndZ(p,v,T),C=t.getResolution(v),g=T.minX;g<=T.maxX;++g)for(I=T.minY;I<=T.maxY;++I)l&&!t.tileCoordIntersectsViewport([v,g,I],m)||(s-v<=x?(++w,R=i.getTile(v,g,I,o,d),R.getState()==D.IDLE&&(r[R.getKey()]=!0,u.isKeyQueued(R.getKey())||u.enqueue([R,h,t.getTileCoordCenter(R.tileCoord),C])),n!==void 0&&n(R)):i.useTile(v,g,I,d));i.updateCacheSize(w,d)}}const Ye=Oe;export{Ye as C};
