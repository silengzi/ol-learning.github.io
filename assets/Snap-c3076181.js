import{ay as R,N as L,bX as b,cR as D,Y as x,Q as j,e as F,F as y,E as A,G,bV as T,cM as E,r as O,aN as w,cO as C,cY as B,cP as U,cW as K,t as V}from"./Layer-3211d6ef.js";import{R as N,a as S}from"./Vector-163f0152.js";const q={SNAP:"snap"};class Y extends R{constructor(e,t){super(e),this.vertex=t.vertex,this.vertexPixel=t.vertexPixel,this.feature=t.feature}}function M(f){return f.feature?f.feature:f.element?f.element:null}const v=[];class k extends L{constructor(e){e=e||{};const t=e;t.handleDownEvent||(t.handleDownEvent=b),t.stopDown||(t.stopDown=D),super(t),this.on,this.once,this.un,this.source_=e.source?e.source:null,this.vertex_=e.vertex!==void 0?e.vertex:!0,this.edge_=e.edge!==void 0?e.edge:!0,this.features_=e.features?e.features:null,this.featuresListenerKeys_=[],this.featureChangeListenerKeys_={},this.indexedFeaturesExtents_={},this.pendingFeatures_={},this.pixelTolerance_=e.pixelTolerance!==void 0?e.pixelTolerance:10,this.rBush_=new N,this.GEOMETRY_SEGMENTERS_={Point:this.segmentPointGeometry_.bind(this),LineString:this.segmentLineStringGeometry_.bind(this),LinearRing:this.segmentLineStringGeometry_.bind(this),Polygon:this.segmentPolygonGeometry_.bind(this),MultiPoint:this.segmentMultiPointGeometry_.bind(this),MultiLineString:this.segmentMultiLineStringGeometry_.bind(this),MultiPolygon:this.segmentMultiPolygonGeometry_.bind(this),GeometryCollection:this.segmentGeometryCollectionGeometry_.bind(this),Circle:this.segmentCircleGeometry_.bind(this)}}addFeature(e,t){t=t!==void 0?t:!0;const n=x(e),s=e.getGeometry();if(s){const o=this.GEOMETRY_SEGMENTERS_[s.getType()];if(o){this.indexedFeaturesExtents_[n]=s.getExtent(j());const i=[];if(o(i,s),i.length===1)this.rBush_.insert(F(i[0]),{feature:e,segment:i[0]});else if(i.length>1){const r=i.map(l=>F(l)),a=i.map(l=>({feature:e,segment:l}));this.rBush_.load(r,a)}}}t&&(this.featureChangeListenerKeys_[n]=y(e,A.CHANGE,this.handleFeatureChange_,this))}getFeatures_(){let e;return this.features_?e=this.features_:this.source_&&(e=this.source_.getFeatures()),e}handleEvent(e){const t=this.snapTo(e.pixel,e.coordinate,e.map);return t&&(e.coordinate=t.vertex.slice(0,2),e.pixel=t.vertexPixel,this.dispatchEvent(new Y(q.SNAP,{vertex:e.coordinate,vertexPixel:e.pixel,feature:t.feature}))),super.handleEvent(e)}handleFeatureAdd_(e){const t=M(e);t&&this.addFeature(t)}handleFeatureRemove_(e){const t=M(e);t&&this.removeFeature(t)}handleFeatureChange_(e){const t=e.target;if(this.handlingDownUpSequence){const n=x(t);n in this.pendingFeatures_||(this.pendingFeatures_[n]=t)}else this.updateFeature_(t)}handleUpEvent(e){const t=Object.values(this.pendingFeatures_);return t.length&&(t.forEach(this.updateFeature_.bind(this)),this.pendingFeatures_={}),!1}removeFeature(e,t){const n=t!==void 0?t:!0,s=x(e),o=this.indexedFeaturesExtents_[s];if(o){const i=this.rBush_,r=[];i.forEachInExtent(o,function(a){e===a.feature&&r.push(a)});for(let a=r.length-1;a>=0;--a)i.remove(r[a])}n&&(G(this.featureChangeListenerKeys_[s]),delete this.featureChangeListenerKeys_[s])}setMap(e){const t=this.getMap(),n=this.featuresListenerKeys_,s=this.getFeatures_();t&&(n.forEach(G),n.length=0,this.rBush_.clear(),Object.values(this.featureChangeListenerKeys_).forEach(G),this.featureChangeListenerKeys_={}),super.setMap(e),e&&(this.features_?n.push(y(this.features_,T.ADD,this.handleFeatureAdd_,this),y(this.features_,T.REMOVE,this.handleFeatureRemove_,this)):this.source_&&n.push(y(this.source_,S.ADDFEATURE,this.handleFeatureAdd_,this),y(this.source_,S.REMOVEFEATURE,this.handleFeatureRemove_,this)),s.forEach(o=>this.addFeature(o)))}snapTo(e,t,n){n.getView().getProjection();const s=E(t),o=O(w(F([s]),n.getView().getResolution()*this.pixelTolerance_)),i=this.rBush_.getInExtent(o),r=i.length;if(r===0)return null;let a,l=1/0,d;const p=this.pixelTolerance_*this.pixelTolerance_,P=()=>{if(a){const h=n.getPixelFromCoordinate(a);if(C(e,h)<=p)return{vertex:a,vertexPixel:[Math.round(h[0]),Math.round(h[1])],feature:d}}return null};if(this.vertex_){for(let c=0;c<r;++c){const u=i[c];u.feature.getGeometry().getType()!=="Circle"&&u.segment.forEach(m=>{const g=E(m),_=C(s,g);_<l&&(a=m,l=_,d=u.feature)})}const h=P();if(h)return h}if(this.edge_){for(let c=0;c<r;++c){let u=null;const m=i[c];if(m.feature.getGeometry().getType()==="Circle"){let g=m.feature.getGeometry();u=B(s,g)}else{const[g,_]=m.segment;_&&(v[0]=E(g),v[1]=E(_),u=U(s,v))}if(u){const g=C(s,u);g<l&&(a=V(u),l=g)}}const h=P();if(h)return h}return null}updateFeature_(e){this.removeFeature(e,!1),this.addFeature(e,!1)}segmentCircleGeometry_(e,t){this.getMap().getView().getProjection();const o=K(t).getCoordinates()[0];for(let i=0,r=o.length-1;i<r;++i)e.push(o.slice(i,i+2))}segmentGeometryCollectionGeometry_(e,t){const n=t.getGeometriesArray();for(let s=0;s<n.length;++s){const o=this.GEOMETRY_SEGMENTERS_[n[s].getType()];o&&o(e,n[s])}}segmentLineStringGeometry_(e,t){const n=t.getCoordinates();for(let s=0,o=n.length-1;s<o;++s)e.push(n.slice(s,s+2))}segmentMultiLineStringGeometry_(e,t){const n=t.getCoordinates();for(let s=0,o=n.length;s<o;++s){const i=n[s];for(let r=0,a=i.length-1;r<a;++r)e.push(i.slice(r,r+2))}}segmentMultiPointGeometry_(e,t){t.getCoordinates().forEach(n=>{e.push([n])})}segmentMultiPolygonGeometry_(e,t){const n=t.getCoordinates();for(let s=0,o=n.length;s<o;++s){const i=n[s];for(let r=0,a=i.length;r<a;++r){const l=i[r];for(let d=0,p=l.length-1;d<p;++d)e.push(l.slice(d,d+2))}}}segmentPointGeometry_(e,t){e.push([t.getCoordinates()])}segmentPolygonGeometry_(e,t){const n=t.getCoordinates();for(let s=0,o=n.length;s<o;++s){const i=n[s];for(let r=0,a=i.length-1;r<a;++r)e.push(i.slice(r,r+2))}}}const Q=k;export{Q as S};
