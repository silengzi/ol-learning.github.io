import{C as v}from"./Circle-12fbc9db.js";import{T as K,cR as Y,bZ as $,cM as w,cO as A,cU as Z,cK as G,cf as z,cV as J,H as Q,cH as m,cW as tt,m as V,cL as j,P as M,cX as O,aD as et,a as R,bR as it,by as q,ce as st,cT as nt,cY as ot,ag as N,af as rt,ae as at,a6 as ht,B as ct}from"./Layer-227d2e40.js";import{V as lt,F as k}from"./Vector-dc05cca5.js";import{G as dt}from"./GeometryCollection-66a09ebd.js";import{L as F}from"./LineString-72752817.js";import{M as U,a as b}from"./MultiPolygon-4cf6e085.js";import{M as ft}from"./MultiPoint-97d710ff.js";import{V as _t}from"./Vector-1db23811.js";import{d as ut}from"./Style-f78957a3.js";const T={DRAWSTART:"drawstart",DRAWEND:"drawend",DRAWABORT:"drawabort"};class P extends et{constructor(t,e){super(t),this.feature=e}}function gt(a,t){const e=[];for(let i=0;i<t.length;++i){const o=t[i].getGeometry();H(a,o,e)}return e}function x(a,t){return q(a[0],a[1],t[0],t[1])}function C(a,t){const e=a.length;return t<0?a[t+e]:t>=e?a[t-e]:a[t]}function D(a,t,e){let i,s;t<e?(i=t,s=e):(i=e,s=t);const o=Math.ceil(i),n=Math.floor(s);if(o>n){const h=y(a,i),c=y(a,s);return x(h,c)}let r=0;if(i<o){const h=y(a,i),c=C(a,o);r+=x(h,c)}if(n<s){const h=C(a,n),c=y(a,s);r+=x(h,c)}for(let h=o;h<n-1;++h){const c=C(a,h),d=C(a,h+1);r+=x(c,d)}return r}function H(a,t,e){if(t instanceof F){L(a,t.getCoordinates(),!1,e);return}if(t instanceof U){const i=t.getCoordinates();for(let s=0,o=i.length;s<o;++s)L(a,i[s],!1,e);return}if(t instanceof R){const i=t.getCoordinates();for(let s=0,o=i.length;s<o;++s)L(a,i[s],!0,e);return}if(t instanceof b){const i=t.getCoordinates();for(let s=0,o=i.length;s<o;++s){const n=i[s];for(let r=0,h=n.length;r<h;++r)L(a,n[r],!0,e)}return}if(t instanceof dt){const i=t.getGeometries();for(let s=0;s<i.length;++s)H(a,i[s],e);return}}const I={index:-1,endIndex:NaN};function mt(a,t,e,i){const s=a[0],o=a[1];let n=1/0,r=-1,h=NaN;for(let l=0;l<t.targets.length;++l){const f=t.targets[l],_=f.coordinates;let u=1/0,g;for(let p=0;p<_.length-1;++p){const B=_[p],X=_[p+1],S=W(s,o,B,X);S.squaredDistance<u&&(u=S.squaredDistance,g=p+S.along)}u<n&&(n=u,f.ring&&t.targetIndex===l&&(f.endIndex>f.startIndex?g<f.startIndex&&(g+=_.length):f.endIndex<f.startIndex&&g>f.startIndex&&(g-=_.length)),h=g,r=l)}const c=t.targets[r];let d=c.ring;if(t.targetIndex===r&&d){const l=y(c.coordinates,h),f=e.getPixelFromCoordinate(l);j(f,t.startPx)>i&&(d=!1)}if(d){const l=c.coordinates,f=l.length,_=c.startIndex,u=h;if(_<u){const g=D(l,_,u);D(l,_,u-f)<g&&(h-=f)}else{const g=D(l,_,u);D(l,_,u+f)<g&&(h+=f)}}return I.index=r,I.endIndex=h,I}function L(a,t,e,i){const s=a[0],o=a[1];for(let n=0,r=t.length-1;n<r;++n){const h=t[n],c=t[n+1],d=W(s,o,h,c);if(d.squaredDistance===0){const l=n+d.along;i.push({coordinates:t,ring:e,startIndex:l,endIndex:l});return}}}const E={along:0,squaredDistance:0};function W(a,t,e,i){const s=e[0],o=e[1],n=i[0],r=i[1],h=n-s,c=r-o;let d=0,l=s,f=o;return(h!==0||c!==0)&&(d=ct(((a-s)*h+(t-o)*c)/(h*h+c*c),0,1),l+=h*d,f+=c*d),E.along=d,E.squaredDistance=it(q(a,t,l,f),10),E}function y(a,t){const e=a.length;let i=Math.floor(t);const s=t-i;i>=e?i-=e:i<0&&(i+=e);let o=i+1;o>=e&&(o-=e);const n=a[i],r=n[0],h=n[1],c=a[o],d=c[0]-r,l=c[1]-h;return[r+d*s,h+l*s]}class pt extends K{constructor(t){const e=t;e.stopDown||(e.stopDown=Y),super(e),this.on,this.once,this.un,this.shouldHandle_=!1,this.downPx_=null,this.downTimeout_,this.lastDragTime_,this.pointerType_,this.freehand_=!1,this.source_=t.source?t.source:null,this.features_=t.features?t.features:null,this.snapTolerance_=t.snapTolerance?t.snapTolerance:12,this.type_=t.type,this.mode_=yt(this.type_),this.stopClick_=!!t.stopClick,this.minPoints_=t.minPoints?t.minPoints:this.mode_==="Polygon"?3:2,this.maxPoints_=this.mode_==="Circle"?2:t.maxPoints?t.maxPoints:1/0,this.finishCondition_=t.finishCondition?t.finishCondition:$,this.geometryLayout_=t.geometryLayout?t.geometryLayout:"XY";let i=t.geometryFunction;if(!i){const s=this.mode_;if(s==="Circle")i=function(o,n,r){const h=n||new v([NaN,NaN]),c=w(o[0]),d=A(c,w(o[o.length-1]));return h.setCenterAndRadius(c,Math.sqrt(d),this.geometryLayout_),h};else{let o;s==="Point"?o=M:s==="LineString"?o=F:s==="Polygon"&&(o=R),i=function(n,r,h){return r?s==="Polygon"?n[0].length?r.setCoordinates([n[0].concat([n[0][0]])],this.geometryLayout_):r.setCoordinates([],this.geometryLayout_):r.setCoordinates(n,this.geometryLayout_):r=new o(n,this.geometryLayout_),r}}}this.geometryFunction_=i,this.dragVertexDelay_=t.dragVertexDelay!==void 0?t.dragVertexDelay:500,this.finishCoordinate_=null,this.sketchFeature_=null,this.sketchPoint_=null,this.sketchCoords_=null,this.sketchLine_=null,this.sketchLineCoords_=null,this.squaredClickTolerance_=t.clickTolerance?t.clickTolerance*t.clickTolerance:36,this.overlay_=new _t({source:new lt({useSpatialIndex:!1,wrapX:t.wrapX?t.wrapX:!1}),style:t.style?t.style:Ct(),updateWhileInteracting:!0}),this.geometryName_=t.geometryName,this.condition_=t.condition?t.condition:Z,this.freehandCondition_,t.freehand?this.freehandCondition_=G:this.freehandCondition_=t.freehandCondition?t.freehandCondition:z,this.traceCondition_,this.setTrace(t.trace||!1),this.traceState_={active:!1},this.traceSource_=t.traceSource||t.source||null,this.addChangeListener(J.ACTIVE,this.updateState_)}setTrace(t){let e;t?t===!0?e=G:e=t:e=st,this.traceCondition_=e}setMap(t){super.setMap(t),this.updateState_()}getOverlay(){return this.overlay_}handleEvent(t){t.originalEvent.type===Q.CONTEXTMENU&&t.originalEvent.preventDefault(),this.freehand_=this.mode_!=="Point"&&this.freehandCondition_(t);let e=t.type===m.POINTERMOVE,i=!0;return!this.freehand_&&this.lastDragTime_&&t.type===m.POINTERDRAG&&(Date.now()-this.lastDragTime_>=this.dragVertexDelay_?(this.downPx_=t.pixel,this.shouldHandle_=!this.freehand_,e=!0):this.lastDragTime_=void 0,this.shouldHandle_&&this.downTimeout_!==void 0&&(clearTimeout(this.downTimeout_),this.downTimeout_=void 0)),this.freehand_&&t.type===m.POINTERDRAG&&this.sketchFeature_!==null?(this.addToDrawing_(t.coordinate),i=!1):this.freehand_&&t.type===m.POINTERDOWN?i=!1:e&&this.getPointerCount()<2?(i=t.type===m.POINTERMOVE,i&&this.freehand_?(this.handlePointerMove_(t),this.shouldHandle_&&t.originalEvent.preventDefault()):(t.originalEvent.pointerType==="mouse"||t.type===m.POINTERDRAG&&this.downTimeout_===void 0)&&this.handlePointerMove_(t)):t.type===m.DBLCLICK&&(i=!1),super.handleEvent(t)&&i}handleDownEvent(t){return this.shouldHandle_=!this.freehand_,this.freehand_?(this.downPx_=t.pixel,this.finishCoordinate_||this.startDrawing_(t.coordinate),!0):this.condition_(t)?(this.lastDragTime_=Date.now(),this.downTimeout_=setTimeout(()=>{this.handlePointerMove_(new tt(m.POINTERMOVE,t.map,t.originalEvent,!1,t.frameState))},this.dragVertexDelay_),this.downPx_=t.pixel,!0):(this.lastDragTime_=void 0,!1)}deactivateTrace_(){this.traceState_={active:!1}}toggleTraceState_(t){if(!this.traceSource_||!this.traceCondition_(t))return;if(this.traceState_.active){this.deactivateTrace_();return}const e=this.getMap(),i=e.getCoordinateFromPixel([t.pixel[0]-this.snapTolerance_,t.pixel[1]+this.snapTolerance_]),s=e.getCoordinateFromPixel([t.pixel[0]+this.snapTolerance_,t.pixel[1]-this.snapTolerance_]),o=V([i,s]),n=this.traceSource_.getFeaturesInExtent(o);if(n.length===0)return;const r=gt(t.coordinate,n);r.length&&(this.traceState_={active:!0,startPx:t.pixel.slice(),targets:r,targetIndex:-1})}addOrRemoveTracedCoordinates_(t,e){const i=t.startIndex<=t.endIndex,s=t.startIndex<=e;i===s?i&&e>t.endIndex||!i&&e<t.endIndex?this.addTracedCoordinates_(t,t.endIndex,e):(i&&e<t.endIndex||!i&&e>t.endIndex)&&this.removeTracedCoordinates_(e,t.endIndex):(this.removeTracedCoordinates_(t.startIndex,t.endIndex),this.addTracedCoordinates_(t,t.startIndex,e))}removeTracedCoordinates_(t,e){if(t===e)return;let i=0;if(t<e){const s=Math.ceil(t);let o=Math.floor(e);o===e&&(o-=1),i=o-s+1}else{const s=Math.floor(t);let o=Math.ceil(e);o===e&&(o+=1),i=s-o+1}i>0&&this.removeLastPoints_(i)}addTracedCoordinates_(t,e,i){if(e===i)return;const s=[];if(e<i){const o=Math.ceil(e);let n=Math.floor(i);n===i&&(n-=1);for(let r=o;r<=n;++r)s.push(C(t.coordinates,r))}else{const o=Math.floor(e);let n=Math.ceil(i);n===i&&(n+=1);for(let r=o;r>=n;--r)s.push(C(t.coordinates,r))}s.length&&this.appendCoordinates(s)}updateTrace_(t){const e=this.traceState_;if(!e.active||e.targetIndex===-1&&j(e.startPx,t.pixel)<this.snapTolerance_)return;const i=mt(t.coordinate,e,this.getMap(),this.snapTolerance_);if(e.targetIndex!==i.index){if(e.targetIndex!==-1){const h=e.targets[e.targetIndex];this.removeTracedCoordinates_(h.startIndex,h.endIndex)}const r=e.targets[i.index];this.addTracedCoordinates_(r,r.startIndex,i.endIndex)}else{const r=e.targets[e.targetIndex];this.addOrRemoveTracedCoordinates_(r,i.endIndex)}e.targetIndex=i.index;const s=e.targets[e.targetIndex];s.endIndex=i.endIndex;const o=y(s.coordinates,s.endIndex),n=this.getMap().getPixelFromCoordinate(o);t.coordinate=o,t.pixel=[Math.round(n[0]),Math.round(n[1])]}handleUpEvent(t){let e=!0;if(this.getPointerCount()===0){this.downTimeout_&&(clearTimeout(this.downTimeout_),this.downTimeout_=void 0),this.handlePointerMove_(t);const i=this.traceState_.active;if(this.toggleTraceState_(t),this.shouldHandle_){const s=!this.finishCoordinate_;s&&this.startDrawing_(t.coordinate),!s&&this.freehand_?this.finishDrawing():!this.freehand_&&(!s||this.mode_==="Point")&&(this.atFinish_(t.pixel,i)?this.finishCondition_(t)&&this.finishDrawing():this.addToDrawing_(t.coordinate)),e=!1}else this.freehand_&&this.abortDrawing()}return!e&&this.stopClick_&&t.preventDefault(),e}handlePointerMove_(t){if(this.pointerType_=t.originalEvent.pointerType,this.downPx_&&(!this.freehand_&&this.shouldHandle_||this.freehand_&&!this.shouldHandle_)){const e=this.downPx_,i=t.pixel,s=e[0]-i[0],o=e[1]-i[1],n=s*s+o*o;if(this.shouldHandle_=this.freehand_?n>this.squaredClickTolerance_:n<=this.squaredClickTolerance_,!this.shouldHandle_)return}if(!this.finishCoordinate_){this.createOrUpdateSketchPoint_(t.coordinate.slice());return}this.updateTrace_(t),this.modifyDrawing_(t.coordinate)}atFinish_(t,e){let i=!1;if(this.sketchFeature_){let s=!1,o=[this.finishCoordinate_];const n=this.mode_;if(n==="Point")i=!0;else if(n==="Circle")i=this.sketchCoords_.length===2;else if(n==="LineString")s=!e&&this.sketchCoords_.length>this.minPoints_;else if(n==="Polygon"){const r=this.sketchCoords_;s=r[0].length>this.minPoints_,o=[r[0][0],r[0][r[0].length-2]],e?o=[r[0][0]]:o=[r[0][0],r[0][r[0].length-2]]}if(s){const r=this.getMap();for(let h=0,c=o.length;h<c;h++){const d=o[h],l=r.getPixelFromCoordinate(d),f=t[0]-l[0],_=t[1]-l[1],u=this.freehand_?1:this.snapTolerance_;if(i=Math.sqrt(f*f+_*_)<=u,i){this.finishCoordinate_=d;break}}}}return i}createOrUpdateSketchPoint_(t){this.sketchPoint_?this.sketchPoint_.getGeometry().setCoordinates(t):(this.sketchPoint_=new k(new M(t)),this.updateSketchFeatures_())}createOrUpdateCustomSketchLine_(t){this.sketchLine_||(this.sketchLine_=new k);const e=t.getLinearRing(0);let i=this.sketchLine_.getGeometry();i?(i.setFlatCoordinates(e.getLayout(),e.getFlatCoordinates()),i.changed()):(i=new F(e.getFlatCoordinates(),e.getLayout()),this.sketchLine_.setGeometry(i))}startDrawing_(t){const e=this.getMap().getView().getProjection(),i=O(this.geometryLayout_);for(;t.length<i;)t.push(0);this.finishCoordinate_=t,this.mode_==="Point"?this.sketchCoords_=t.slice():this.mode_==="Polygon"?(this.sketchCoords_=[[t.slice(),t.slice()]],this.sketchLineCoords_=this.sketchCoords_[0]):this.sketchCoords_=[t.slice(),t.slice()],this.sketchLineCoords_&&(this.sketchLine_=new k(new F(this.sketchLineCoords_)));const s=this.geometryFunction_(this.sketchCoords_,void 0,e);this.sketchFeature_=new k,this.geometryName_&&this.sketchFeature_.setGeometryName(this.geometryName_),this.sketchFeature_.setGeometry(s),this.updateSketchFeatures_(),this.dispatchEvent(new P(T.DRAWSTART,this.sketchFeature_))}modifyDrawing_(t){const e=this.getMap(),i=this.sketchFeature_.getGeometry(),s=e.getView().getProjection(),o=O(this.geometryLayout_);let n,r;for(;t.length<o;)t.push(0);this.mode_==="Point"?r=this.sketchCoords_:this.mode_==="Polygon"?(n=this.sketchCoords_[0],r=n[n.length-1],this.atFinish_(e.getPixelFromCoordinate(t))&&(t=this.finishCoordinate_.slice())):(n=this.sketchCoords_,r=n[n.length-1]),r[0]=t[0],r[1]=t[1],this.geometryFunction_(this.sketchCoords_,i,s),this.sketchPoint_&&this.sketchPoint_.getGeometry().setCoordinates(t),i.getType()==="Polygon"&&this.mode_!=="Polygon"?this.createOrUpdateCustomSketchLine_(i):this.sketchLineCoords_&&this.sketchLine_.getGeometry().setCoordinates(this.sketchLineCoords_),this.updateSketchFeatures_()}addToDrawing_(t){const e=this.sketchFeature_.getGeometry(),i=this.getMap().getView().getProjection();let s,o;const n=this.mode_;n==="LineString"||n==="Circle"?(this.finishCoordinate_=t.slice(),o=this.sketchCoords_,o.length>=this.maxPoints_&&(this.freehand_?o.pop():s=!0),o.push(t.slice()),this.geometryFunction_(o,e,i)):n==="Polygon"&&(o=this.sketchCoords_[0],o.length>=this.maxPoints_&&(this.freehand_?o.pop():s=!0),o.push(t.slice()),s&&(this.finishCoordinate_=o[0]),this.geometryFunction_(this.sketchCoords_,e,i)),this.createOrUpdateSketchPoint_(t.slice()),this.updateSketchFeatures_(),s&&this.finishDrawing()}removeLastPoints_(t){if(!this.sketchFeature_)return;const e=this.sketchFeature_.getGeometry(),i=this.getMap().getView().getProjection(),s=this.mode_;for(let o=0;o<t;++o){let n;if(s==="LineString"||s==="Circle"){if(n=this.sketchCoords_,n.splice(-2,1),n.length>=2){this.finishCoordinate_=n[n.length-2].slice();const r=this.finishCoordinate_.slice();n[n.length-1]=r,this.createOrUpdateSketchPoint_(r)}this.geometryFunction_(n,e,i),e.getType()==="Polygon"&&this.sketchLine_&&this.createOrUpdateCustomSketchLine_(e)}else if(s==="Polygon"){n=this.sketchCoords_[0],n.splice(-2,1);const r=this.sketchLine_.getGeometry();if(n.length>=2){const h=n[n.length-2].slice();n[n.length-1]=h,this.createOrUpdateSketchPoint_(h)}r.setCoordinates(n),this.geometryFunction_(this.sketchCoords_,e,i)}if(n.length===1){this.abortDrawing();break}}this.updateSketchFeatures_()}removeLastPoint(){this.removeLastPoints_(1)}finishDrawing(){const t=this.abortDrawing_();if(!t)return;let e=this.sketchCoords_;const i=t.getGeometry(),s=this.getMap().getView().getProjection();this.mode_==="LineString"?(e.pop(),this.geometryFunction_(e,i,s)):this.mode_==="Polygon"&&(e[0].pop(),this.geometryFunction_(e,i,s),e=i.getCoordinates()),this.type_==="MultiPoint"?t.setGeometry(new ft([e])):this.type_==="MultiLineString"?t.setGeometry(new U([e])):this.type_==="MultiPolygon"&&t.setGeometry(new b([e])),this.dispatchEvent(new P(T.DRAWEND,t)),this.features_&&this.features_.push(t),this.source_&&this.source_.addFeature(t)}abortDrawing_(){this.finishCoordinate_=null;const t=this.sketchFeature_;return this.sketchFeature_=null,this.sketchPoint_=null,this.sketchLine_=null,this.overlay_.getSource().clear(!0),this.deactivateTrace_(),t}abortDrawing(){const t=this.abortDrawing_();t&&this.dispatchEvent(new P(T.DRAWABORT,t))}appendCoordinates(t){const e=this.mode_,i=!this.sketchFeature_;i&&this.startDrawing_(t[0]);let s;if(e==="LineString"||e==="Circle")s=this.sketchCoords_;else if(e==="Polygon")s=this.sketchCoords_&&this.sketchCoords_.length?this.sketchCoords_[0]:[];else return;i&&s.shift(),s.pop();for(let n=0;n<t.length;n++)this.addToDrawing_(t[n]);const o=t[t.length-1];this.addToDrawing_(o),this.modifyDrawing_(o)}extend(t){const i=t.getGeometry();this.sketchFeature_=t,this.sketchCoords_=i.getCoordinates();const s=this.sketchCoords_[this.sketchCoords_.length-1];this.finishCoordinate_=s.slice(),this.sketchCoords_.push(s.slice()),this.sketchPoint_=new k(new M(s)),this.updateSketchFeatures_(),this.dispatchEvent(new P(T.DRAWSTART,this.sketchFeature_))}updateSketchFeatures_(){const t=[];this.sketchFeature_&&t.push(this.sketchFeature_),this.sketchLine_&&t.push(this.sketchLine_),this.sketchPoint_&&t.push(this.sketchPoint_);const e=this.overlay_.getSource();e.clear(!0),e.addFeatures(t)}updateState_(){const t=this.getMap(),e=this.getActive();(!t||!e)&&this.abortDrawing(),this.overlay_.setMap(e?t:null)}}function Ct(){const a=ut();return function(t,e){return a[t.getGeometry().getType()]}}function Mt(a,t){return function(e,i,s){const o=w(e[0]),n=w(e[e.length-1]),r=Math.sqrt(A(o,n));i=i||nt(new v(o),a);let h=t;if(!t&&t!==0){const c=n[0]-o[0],d=n[1]-o[1];h=Math.atan2(d,c)}return ot(i,o,r,h),i}}function It(){return function(a,t,e){const i=V([a[0],a[a.length-1]].map(function(o){return w(o)})),s=[[N(i),rt(i),at(i),ht(i),N(i)]];return t?t.setCoordinates(s):t=new R(s),t}}function yt(a){switch(a){case"Point":case"MultiPoint":return"Point";case"LineString":case"MultiLineString":return"LineString";case"Polygon":case"MultiPolygon":return"Polygon";case"Circle":return"Circle";default:throw new Error("Invalid type: "+a)}}const Et=pt;export{Et as D,It as a,Mt as c};
