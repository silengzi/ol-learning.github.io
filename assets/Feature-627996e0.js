import{F as P,R as d}from"./featureloader-a90a5108.js";import{g as c,ac as s,aa as g,af as p,P as F,U as h,aY as j,aZ as M,a_ as A,a$ as G}from"./Layer-3b715193.js";import{G as R,a as w,M as L}from"./MultiPolygon-d7736349.js";import{L as O}from"./LineString-eed53b5a.js";import{M as T}from"./MultiPoint-74fca651.js";class x{constructor(){this.dataProjection=void 0,this.defaultFeatureProjection=void 0,this.featureClass=P,this.supportedMediaTypes=null}getReadOptions(t,e){if(e){let n=e.dataProjection?c(e.dataProjection):this.readProjection(t);e.extent&&n&&n.getUnits()==="tile-pixels"&&(n=c(n),n.setWorldExtent(e.extent)),e={dataProjection:n,featureProjection:e.featureProjection}}return this.adaptOptions(e)}adaptOptions(t){return Object.assign({dataProjection:this.dataProjection,featureProjection:this.defaultFeatureProjection,featureClass:this.featureClass},t)}getType(){return s()}readFeature(t,e){return s()}readFeatures(t,e){return s()}readGeometry(t,e){return s()}readProjection(t){return s()}writeFeature(t,e){return s()}writeFeatures(t,e){return s()}writeGeometry(t,e){return s()}}const Z=x;function m(r,t,e){const n=e?c(e.featureProjection):null,i=e?c(e.dataProjection):null;let a=r;if(n&&i&&!g(n,i)){t&&(a=r.clone());const o=t?n:i,u=t?i:n;o.getUnits()==="tile-pixels"?a.transform(o,u):a.applyTransform(p(o,u))}if(t&&e&&e.decimals!==void 0){const o=Math.pow(10,e.decimals),u=function(l){for(let f=0,y=l.length;f<y;++f)l[f]=Math.round(l[f]*o)/o;return l};a===r&&(a=r.clone()),a.applyTransform(u)}return a}const S={Point:F,LineString:O,Polygon:h,MultiPoint:T,MultiLineString:w,MultiPolygon:L};function U(r,t,e){return Array.isArray(t[0])?(j(r,0,t,e)||(r=r.slice(),M(r,0,t,e)),r):(A(r,0,t,e)||(r=r.slice(),G(r,0,t,e)),r)}function C(r,t){var a;const e=r.geometry;if(!e)return[];if(Array.isArray(e))return e.map(o=>C({...r,geometry:o})).flat();const n=e.type==="MultiPolygon"?"Polygon":e.type;if(n==="GeometryCollection"||n==="Circle")throw new Error("Unsupported geometry type: "+n);const i=e.layout.length;return m(new d(n,n==="Polygon"?U(e.flatCoordinates,e.ends,i):e.flatCoordinates,(a=e.ends)==null?void 0:a.flat(),i,r.properties||{},r.id).enableSimplifyTransformed(),!1,t)}function E(r,t){if(!r)return null;if(Array.isArray(r)){const n=r.map(i=>E(i,t));return new R(n)}const e=S[r.type];return m(new e(r.flatCoordinates,r.layout,r.ends),!1,t)}export{Z as F,E as a,C as c,m as t};
